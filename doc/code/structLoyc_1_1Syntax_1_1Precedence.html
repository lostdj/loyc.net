<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Enhanced C#: Loyc.Syntax.Precedence Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<h1>Documentation moved to <a href="http://ecsharp.net/doc/code">ecsharp.net</a></h1>
<small>GitHub doesn't support HTTP redirects, so you'll be redirected in 3 seconds.</small>
<br/><br/>
<script>
setTimeout(function() {
	if (window.location.href.indexOf('http://loyc.net') == 0) {
	  window.location.href = 'http://ecsharp.net' + window.location.href.substr('http://loyc.net'.length);
	}
}, 3000);
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Syntax.html">Syntax</a></li><li class="navelem"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public fields</a> &#124;
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structLoyc_1_1Syntax_1_1Precedence-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Syntax.Precedence Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A four-byte tuple that represents the precedence and miscibility of an operator. 
 <a href="structLoyc_1_1Syntax_1_1Precedence.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Syntax/Parsing/Precedence.cs'>/Core/Loyc.Syntax/Parsing/Precedence.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Syntax.Precedence:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structLoyc_1_1Syntax_1_1Precedence.png" usemap="#Loyc.Syntax.Precedence_map" alt=""/>
  <map id="Loyc.Syntax.Precedence_map" name="Loyc.Syntax.Precedence_map">
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>A four-byte tuple that represents the precedence and miscibility of an operator.</p>
<p>An operator's precedence is encoded in the two numbers, <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aa336b14413bbed1bc0192bf90d297295" title="Left and Right denote the precedence level on the left and right sides of an operator; see the remark...">Left</a> and Right. These numbers encode the knowledge that, for example, <code>x &amp; y == z</code> will be parsed as <code>x &amp; (y == z)</code>. For normal left-associative operators, Left and Right are the same. However, some operators have different precedence on the left than on the right, a prime example being the =&gt; operator: <code>x = a =&gt; y = a</code> is parsed <code>x = (a =&gt; (y = a))</code>; it has very high precedence on the left, but very low precedence on the right. </p>
<p>To understand how this works, remember that a parser scans from left to right. Each time it encounters a new operator, it needs to figure out whether to include that operator in the current (inner) expression or whether to "complete" the inner expression and bind the operator to an outer expression instead. The concept of a "precedence floor" can be used to make this decision. </p>
<p>For example, suppose we start parsing the expression <code>-a.b + c * d + e</code>. The parser sees "-" first, which must be a prefix operator since there is no expression on the left. The Right precedence of unary '-' is 90 in EC#, so that will be the "precedence floor" to parse the right-hand side. Operators above 90 will be permitted in the right-hand side; operators at 90 or below will not. </p>
<p>The next token is 'a', which is an expression by itself and doesn't have any precedence, so it becomes the initial right-hand expression of '-'. Next we have '.', which has a <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aa336b14413bbed1bc0192bf90d297295" title="Left and Right denote the precedence level on the left and right sides of an operator; see the remark...">Left</a> precedence of 100, which is above the precedence floor of 90 so it can be bound to 'a'. The precedence floor (PF) is raised to 100, and the next token 'b' is bound to '.'. </p>
<p>However, the next token '+' (which must be the binary operator rather than the prefix operator, because there is an expression on the left) cannot be accepted with its precedence of 60. Therefore the expression "a.b" is deemed complete, and the PF is lowered back to 90. Again 60 is less than 90, so the expression "-a.b" is also deemed complete and the PF drops to int.MinValue. This expression becomes the left-hand side of the '+' operator. The PF rises to 60, and "c * d" becomes a subexpression because the precedence of '*' is 70 &gt; 60. However, next we have '+' with precedence 60, which is not above the PF of 60. Therefore, the subexpression "c * d" is deemed complete and the PF lowers to int.MinValue again. Now the '+' can be accepted with a left-hand side of <code>(-(a.b)) + (c * d)</code>, and the right-hand side is, of course, 'e', so the completed expression is <code>((-(a.b)) + (c * d)) + e</code>. Hope that helps! </p>
<p>Notice that <code>a + b + c</code> is parsed <code>(a + b) + c</code>, not <code>a + (b + c)</code>. This is the natural result when the operator's precedence is the same on the left and on the right. However, <code>a = b = c</code> is parsed <code>a = (b = c)</code>, because its precedence is 1 on the left and 0 on the right. When the parser sees the first '=' it sets the PF to 0 because it is about to parse the right side. When it encounters the second '=', the left-hand precedence of that operator is 1 which is higher than the current PF (0) so it is included in the right-hand side of the first '='. This behavior is called "right associativity"; <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#ac587c783e958192a3d409fb8a973b39a" title="Returns true if this object represents a right-associative operator such as equals (x = (y = z))...">IsRightAssociative</a> returns true when <code>Left &gt; Right</code>. </p>
<p>Prefix and suffix operators only have one "side"; you can imagine that the unused side (e.g. the left side of prefix -) has infinite precedence, so that EC# can parse $-x as $(-x) even though the precedence of '-' is supposedly lower than '$'. </p>
<p>Some languages have a conditional operator (a?b:c) with three parts. In the middle part, the PF must drop to Precedence.MinValue so that it is possible to parse <code>a?b=x:c</code> even though '=' supposedly has lower precedence than the conditional operator. Note that <code>a=b ? c=d : e=f</code> is interpreted <code>a=(b ? c=d : e)=f</code>, so you can see that the precedence of the conditional operator is higher at the "edges". </p>
<p>The above explanation illustrates the meaning of Left and Right from the perspective of a parser, but an actual parser may or may not use the PF concept and <code><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a></code> objects. </p>
<p>This struct contains two other numbers, <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a960ac158fb2d0d01817f5a15d4adf694" title="Lo and Hi specify the miscibility of an operator; see the remarks of Precedence for details...">Lo</a> and Hi, which are a precedence range that determines whether and how the operator can be mixed with other operators, as explained below. </p>
<p>A printer (e.g. LesNodePrinter) has a different way of analyzing precedence. It starts with a known parse tree and then has to figure out how to output something that the parser will reconstruct into the original tree. This is more difficult if perfect round-tripping is required: parentheses are encoded in the <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> tree as a #trivia_inParens attribute, so if perfect round-tripping is desired, the printer cannot simply put everything in parens "just to be safe". </p>
<p>Generally, the printer has two ways of printing any expression tree: (1) with operators (e.g. a+b), and (2) with prefix notation (e.g. @+(a, b)). The tree <code>@+(@*(a, b), c)</code> will be printed as "a*b+c" (unless prefix notation is specifically requested) because the precedence rules allow it, but <code>@*(@+(a, b), c)</code> will be printed as <code>@+(a, b)*c</code> because both "a+b*c" and "(a+b)*c" are different from the original tree. </p>
<p>While a parser proceeds from left to right, a printer proceeds from parents to children. So the printer for @*(@+(a, b), c) starts at @* with no precedence restrictions, and roughly speaking will set the precedence floor to LesPrecedence.Multiply in order to print its two children. Since the precedence of @+ (Add) is below Multiply, the + operator is not allowed in that context and either prefix notation or extra parenthesis is used as a fallback (depending on the <a class="el" href="classLoyc_1_1Syntax_1_1Les_1_1LesNodePrinter.html#a4d145df5580f529b86a120ce6795b9c6" title="Introduces extra parenthesis to express precedence, without using an empty attribute list [] to allow...">LesNodePrinter.AllowExtraParenthesis</a> option that permits <code>(a+b)*c</code>). </p>
<p>Printing has numerous "gotchas"; the ones related to precedence are </p><ol>
<li>
Although LesPrecedence.Add has the "same" precedence on the Left and Right, <code>@-(@-(a, b), c)</code> can be printed <code>a - b - c</code> but <code>@-(a, @-(b, c))</code> would have to be printed <code>a - @-(b, c)</code> instead. Clearly, the left and right sides must be treated somehow differently. </li>
<li>
Similarly, the different arguments in <code>a?b:c</code> and <code>a=&gt;b</code> must be treated differently. And careful handling is needed for the dot operator in particular due to its high precedence; e.g. <code>(a(b))</code> cannot be printed <code>.a(b)</code> because that would mean <code>(a)(b)</code>. </li>
<li>
The LES parser, at least, allows a prefix operator to appear on the right-hand side of any infix or prefix operator, regardless of the precedence of the two operators; "$ ++x" is permitted even though ++ has lower precedence than $. Another example is that <code>a.-b.c</code> can be parsed with the interpretation <code>a.(-b).c</code>, even though @- has lower precedence than $. Ideally the printer would replicate this rule, but whether it does ot not, it also must take care that <code>(a, -b.c)</code> is not printed as <code>a.-b.c</code> even though the similar expression <code>@*(a, @-(b.c))</code> can be printed as <code>a*-b.c</code>. </li>
<li>
Prefix notation is needed when an operator's arguments have attributes; <code>@+([Foo] a, b)</code> cannot be printed <code>[Foo] a + b</code> because that would mean <code>[Foo] @+(a, b)</code>. </li>
</ol>
<h3>Printing and parsing are different</h3>
<p>This type contains different methods for printers and parsers. A basic difference between them is that printers must make decisions (of whether an operator is allowed or not in a given context) based on both sides of the operator and both sides of the context (Left and Right), while parsers only have to worry about one side. For example, consider the following expression: </p><div class="fragment"><div class="line">a = b + c ?? d</div>
</div><!-- fragment --><p> When the parser encounters the "+" operator, it only has to consider whether the precedence of the <em>left-hand side</em> of the "+" operator is above the <em>right-hand side</em> of the "=" operator. The fact that there is a "??" later on is irrelevant. In contrast, when printing the expression "b + c", both sides of the "+" operator and both sides of the context must be considered. The right-hand side is relevant because if the right-hand operator was "*" instead of "??", the following printout would be wrong: </p><div class="fragment"><div class="line">a = b + c * d   <span class="comment">// actual syntax tree: a = @+(b, c) * d</span></div>
</div><!-- fragment --><p> The same reasoning applies to the left-hand side (imagine if "=" was "*" instead.) </p>
<p>So, naturally there are different methods for parsing and printing. For printing you can use <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aeca528a19eac804f3d8609337361ce0e" title="For use in printers. Returns true if an infix operator with this precedence can appear in the specifi...">CanAppearIn(Precedence)</a>, <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#af07a82282e299b44ea73a18eac73afd9" title="For use in printers. Auto-raises the precedence floor to prepare to print an expression on the left s...">LeftContext</a> and <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#af7cc55f4627e92274a930ee9021a203e" title="For use in printers. Auto-raises the precedence floor to prepare to print an expression on the right ...">RightContext</a>, while for parsing you only need <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a2d2b5a804370c95545031ed1f5da0df3" title="For use in parsers. Returns true if &#39;rightOp&#39;, an operator on the right, has higher precedence than t...">CanParse</a> (to raise the precedence floor, simply replace the current <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a> value with that of the new operator). In a parser, the "current" precedence is represented by Right; the value of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aa336b14413bbed1bc0192bf90d297295" title="Left and Right denote the precedence level on the left and right sides of an operator; see the remark...">Left</a> doesn't matter. </p>
<p>Both printers and parsers can use <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a494101430520b6ca70b21de7627b1c74" title="Returns true if an operator with this precedence is miscible without parenthesis with the specified o...">CanMixWith</a>.</p>
<h3>Miscibility (mixability)</h3>
<p><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a960ac158fb2d0d01817f5a15d4adf694" title="Lo and Hi specify the miscibility of an operator; see the remarks of Precedence for details...">Lo</a> and Hi don't affect how operators are parsed into a tree, but are used to request a warning or error if operators are mixed improperly. If one operator's range overlaps another AND (the ranges are not equal OR <code>Lo &gt; Hi</code>), then the two operators are immiscible. For example, == and != have the same precedence in EC#, 38..39, so they can be mixed with each other, but they cannot be mixed with &amp; which has the overlapping range 32..45 (this will be explained below.) Normally Lo and Hi are set to <code>Min(Left,Right)</code> and <code>Max(Left,Right)</code> respectively, but this is not required&ndash;in particular, any pair where <code>Lo &gt; Hi</code> is used to indicate that the operator cannot be mixed with other operators of the same precedence, even though it can (perhaps) be mixed with others of different precedence. This is called non-associativity. For example, in PHP are not allowed to write an expression such as <code>x &gt; y &gt;= z</code>; to represent this, operators <code>&gt;</code> and <code>&gt;=</code> should make <code>Lo &gt; Hi</code>. </p>
<p>Certain operators should not be mixed because their precedence was originally chosen incorrectly, e.g. x &amp; 3 == 1 should be parsed (x &amp; 3) == 1 but is actually parsed x &amp; (3 == 1). To allow the precedence to be repaired eventually, expressions like x &amp; y == z are deprecated in EC#: the parser will warn you if you have mixed operators improperly. PrecedenceRange describes both precedence and miscibility with a simple range of integers. As mentioned before, two operators are immiscible if their ranges overlap but are not identical. </p>
<p>In LES, the precedence range feature (a.k.a. immiscibility) is also used to indicate that a specific precedence has not been chosen for an operator. If a precedence is chosen in the future, it will be somewhere within the range.</p>
<h3>Overall <a class="el" href="classLoyc_1_1Range.html">Range</a></h3>
<p>By convention, precedence scales range from 0 to 100 (or slightly higher). The precedence numbers are stored in this structure as <code>sbyte</code>s, so <code>Left</code>, <code>Right</code>, <code>Lo</code>, and <code>Hi</code> must be between -128 and 127. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public fields</h2></td></tr>
<tr class="memitem:a960ac158fb2d0d01817f5a15d4adf694"><td class="memItemLeft" align="right" valign="top">readonly sbyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a960ac158fb2d0d01817f5a15d4adf694">Lo</a></td></tr>
<tr class="memdesc:a960ac158fb2d0d01817f5a15d4adf694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lo and Hi specify the miscibility of an operator; see the remarks of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a> for details. <a href="#a960ac158fb2d0d01817f5a15d4adf694">More...</a><br /></td></tr>
<tr class="separator:a960ac158fb2d0d01817f5a15d4adf694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96860f88e7aa19e0e82295c24e5df515"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96860f88e7aa19e0e82295c24e5df515"></a>
readonly sbyte&#160;</td><td class="memItemRight" valign="bottom"><b>Hi</b></td></tr>
<tr class="separator:a96860f88e7aa19e0e82295c24e5df515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa336b14413bbed1bc0192bf90d297295"><td class="memItemLeft" align="right" valign="top">readonly sbyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aa336b14413bbed1bc0192bf90d297295">Left</a></td></tr>
<tr class="memdesc:aa336b14413bbed1bc0192bf90d297295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left and Right denote the precedence level on the left and right sides of an operator; see the remarks of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a> for details. <a href="#aa336b14413bbed1bc0192bf90d297295">More...</a><br /></td></tr>
<tr class="separator:aa336b14413bbed1bc0192bf90d297295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be1fbcbc9124c7ae6b258bc76bcace1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4be1fbcbc9124c7ae6b258bc76bcace1"></a>
readonly sbyte&#160;</td><td class="memItemRight" valign="bottom"><b>Right</b></td></tr>
<tr class="separator:a4be1fbcbc9124c7ae6b258bc76bcace1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:aaae4ed940b6a1ccffcddacbc598d8ddb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae4ed940b6a1ccffcddacbc598d8ddb"></a>
static <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MinValue</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(sbyte.MinValue)</td></tr>
<tr class="separator:aaae4ed940b6a1ccffcddacbc598d8ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff1acc52cf9c90e13b81642b4e5a3e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ff1acc52cf9c90e13b81642b4e5a3e1"></a>
static <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MaxValue</b> = new <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>(sbyte.MaxValue)</td></tr>
<tr class="separator:a5ff1acc52cf9c90e13b81642b4e5a3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ac587c783e958192a3d409fb8a973b39a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#ac587c783e958192a3d409fb8a973b39a">IsRightAssociative</a><code> [get]</code></td></tr>
<tr class="memdesc:ac587c783e958192a3d409fb8a973b39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this object represents a right-associative operator such as equals (x = (y = z)), in contrast to left- associative operators such as division ((x / y) / z). <a href="#ac587c783e958192a3d409fb8a973b39a">More...</a><br /></td></tr>
<tr class="separator:ac587c783e958192a3d409fb8a973b39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a11dcada0dea777c4e7514e3233799983"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a11dcada0dea777c4e7514e3233799983">Precedence</a> (int actual)</td></tr>
<tr class="memdesc:a11dcada0dea777c4e7514e3233799983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a left-associative operator with the specified precedence. <a href="#a11dcada0dea777c4e7514e3233799983">More...</a><br /></td></tr>
<tr class="separator:a11dcada0dea777c4e7514e3233799983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5a624242388bd069d9bca2075b80df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#acf5a624242388bd069d9bca2075b80df">Precedence</a> (int left, int right)</td></tr>
<tr class="memdesc:acf5a624242388bd069d9bca2075b80df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an operator with different precedence on the left and right sides. For a right associative operator, conventionally <code>right = left-1</code>. <a href="#acf5a624242388bd069d9bca2075b80df">More...</a><br /></td></tr>
<tr class="separator:acf5a624242388bd069d9bca2075b80df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6117080fc5f861365d26832a434a8234"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a6117080fc5f861365d26832a434a8234">Precedence</a> (int left, int right, int lo, int hi)</td></tr>
<tr class="memdesc:a6117080fc5f861365d26832a434a8234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an operator with the given precedence on the left and right sides, and the given immiscibility range (see documentation of this type). <a href="#a6117080fc5f861365d26832a434a8234">More...</a><br /></td></tr>
<tr class="separator:a6117080fc5f861365d26832a434a8234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4bde70863c879906d35189e92e0873"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee4bde70863c879906d35189e92e0873"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Precedence</b> (sbyte left, sbyte right, sbyte lo, sbyte hi)</td></tr>
<tr class="separator:aee4bde70863c879906d35189e92e0873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07a82282e299b44ea73a18eac73afd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#af07a82282e299b44ea73a18eac73afd9">LeftContext</a> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> outerContext)</td></tr>
<tr class="memdesc:af07a82282e299b44ea73a18eac73afd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use in printers. Auto-raises the precedence floor to prepare to print an expression on the left side of an operator. <a href="#af07a82282e299b44ea73a18eac73afd9">More...</a><br /></td></tr>
<tr class="separator:af07a82282e299b44ea73a18eac73afd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cc55f4627e92274a930ee9021a203e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#af7cc55f4627e92274a930ee9021a203e">RightContext</a> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> outerContext)</td></tr>
<tr class="memdesc:af7cc55f4627e92274a930ee9021a203e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use in printers. Auto-raises the precedence floor to prepare to print an expression on the right side of an operator. <a href="#af7cc55f4627e92274a930ee9021a203e">More...</a><br /></td></tr>
<tr class="separator:af7cc55f4627e92274a930ee9021a203e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca528a19eac804f3d8609337361ce0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aeca528a19eac804f3d8609337361ce0e">CanAppearIn</a> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> context)</td></tr>
<tr class="memdesc:aeca528a19eac804f3d8609337361ce0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use in printers. Returns true if an infix operator with this precedence can appear in the specified context. <a href="#aeca528a19eac804f3d8609337361ce0e">More...</a><br /></td></tr>
<tr class="separator:aeca528a19eac804f3d8609337361ce0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f6debe554f34455cbee81f97bb9a40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a54f6debe554f34455cbee81f97bb9a40">CanAppearIn</a> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> context, bool prefix)</td></tr>
<tr class="memdesc:a54f6debe554f34455cbee81f97bb9a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use in printers. Returns true if a prefix operator with this precedence can appear in the specified context's right-hand precedence floor (ignoring miscibility). <a href="#a54f6debe554f34455cbee81f97bb9a40">More...</a><br /></td></tr>
<tr class="separator:a54f6debe554f34455cbee81f97bb9a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494101430520b6ca70b21de7627b1c74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a494101430520b6ca70b21de7627b1c74">CanMixWith</a> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> context)</td></tr>
<tr class="memdesc:a494101430520b6ca70b21de7627b1c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an operator with this precedence is miscible without parenthesis with the specified other operator. <a href="#a494101430520b6ca70b21de7627b1c74">More...</a><br /></td></tr>
<tr class="separator:a494101430520b6ca70b21de7627b1c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2b5a804370c95545031ed1f5da0df3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a2d2b5a804370c95545031ed1f5da0df3">CanParse</a> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> rightOp)</td></tr>
<tr class="memdesc:a2d2b5a804370c95545031ed1f5da0df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use in parsers. Returns true if 'rightOp', an operator on the right, has higher precedence than the current operator 'this'. <a href="#a2d2b5a804370c95545031ed1f5da0df3">More...</a><br /></td></tr>
<tr class="separator:a2d2b5a804370c95545031ed1f5da0df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dce0d00dabbd53ce08926e61a3774a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dce0d00dabbd53ce08926e61a3774a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>RangeEquals</b> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> b)</td></tr>
<tr class="separator:a9dce0d00dabbd53ce08926e61a3774a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5e600402693a977c1f98321d5de869"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb5e600402693a977c1f98321d5de869"></a>
override bool&#160;</td><td class="memItemRight" valign="bottom"><b>Equals</b> (object obj)</td></tr>
<tr class="separator:afb5e600402693a977c1f98321d5de869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1feb2fda4a8db0e918c86beef577ce2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1feb2fda4a8db0e918c86beef577ce2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Equals</b> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> other)</td></tr>
<tr class="separator:af1feb2fda4a8db0e918c86beef577ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330e39fe07690c49bc0313b73bcd1b42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a330e39fe07690c49bc0313b73bcd1b42"></a>
override int&#160;</td><td class="memItemRight" valign="bottom"><b>GetHashCode</b> ()</td></tr>
<tr class="separator:a330e39fe07690c49bc0313b73bcd1b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af476498a3535eec467058cccec99be76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af476498a3535eec467058cccec99be76"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> a, <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> b)</td></tr>
<tr class="separator:af476498a3535eec467058cccec99be76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dabb7ccb718d67ff482ed4399a01b1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dabb7ccb718d67ff482ed4399a01b1d"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> a, <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> b)</td></tr>
<tr class="separator:a4dabb7ccb718d67ff482ed4399a01b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a11dcada0dea777c4e7514e3233799983"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Loyc.Syntax.Precedence.Precedence </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>actual</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a left-associative operator with the specified precedence.</p>

</div>
</div>
<a class="anchor" id="acf5a624242388bd069d9bca2075b80df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Loyc.Syntax.Precedence.Precedence </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes an operator with different precedence on the left and right sides. For a right associative operator, conventionally <code>right = left-1</code>.</p>

</div>
</div>
<a class="anchor" id="a6117080fc5f861365d26832a434a8234"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Loyc.Syntax.Precedence.Precedence </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes an operator with the given precedence on the left and right sides, and the given immiscibility range (see documentation of this type).</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aeca528a19eac804f3d8609337361ce0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Syntax.Precedence.CanAppearIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use in printers. Returns true if an infix operator with this precedence can appear in the specified context.</p>
<p>Miscibility must be checked separately (<a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a494101430520b6ca70b21de7627b1c74" title="Returns true if an operator with this precedence is miscible without parenthesis with the specified o...">CanMixWith</a>).</p>

</div>
</div>
<a class="anchor" id="a54f6debe554f34455cbee81f97bb9a40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Syntax.Precedence.CanAppearIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use in printers. Returns true if a prefix operator with this precedence can appear in the specified context's right-hand precedence floor (ignoring miscibility).</p>
<p>It is assumed that the left side of a prefix operator has "infinite" precedence so only the right side is checked. This rule is used by the EC# printer but may not be needed or allowed in all languages (if in doubt, set prefix=false).</p>

<p>References <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aa336b14413bbed1bc0192bf90d297295">Loyc.Syntax.Precedence.Left</a>.</p>

</div>
</div>
<a class="anchor" id="a494101430520b6ca70b21de7627b1c74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Syntax.Precedence.CanMixWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if an operator with this precedence is miscible without parenthesis with the specified other operator.</p>
<p><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aeca528a19eac804f3d8609337361ce0e" title="For use in printers. Returns true if an infix operator with this precedence can appear in the specifi...">CanAppearIn(Precedence)</a> is for parsability, this method is to detect a deprecated or undefined mixing of operators. </p>

</div>
</div>
<a class="anchor" id="a2d2b5a804370c95545031ed1f5da0df3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Syntax.Precedence.CanParse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td>
          <td class="paramname"><em>rightOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use in parsers. Returns true if 'rightOp', an operator on the right, has higher precedence than the current operator 'this'.</p>
<dl class="section return"><dt>Returns</dt><dd><code>rightOp.Left &gt; this.Right</code></dd></dl>

</div>
</div>
<a class="anchor" id="af07a82282e299b44ea73a18eac73afd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> Loyc.Syntax.Precedence.LeftContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td>
          <td class="paramname"><em>outerContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use in printers. Auto-raises the precedence floor to prepare to print an expression on the left side of an operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outerContext</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>References <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#aa336b14413bbed1bc0192bf90d297295">Loyc.Syntax.Precedence.Left</a>.</p>

</div>
</div>
<a class="anchor" id="af7cc55f4627e92274a930ee9021a203e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a> Loyc.Syntax.Precedence.RightContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html">Precedence</a>&#160;</td>
          <td class="paramname"><em>outerContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use in printers. Auto-raises the precedence floor to prepare to print an expression on the right side of an operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outerContext</td><td>Context in which this operator is being printed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa336b14413bbed1bc0192bf90d297295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly sbyte Loyc.Syntax.Precedence.Left</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left and Right denote the precedence level on the left and right sides of an operator; see the remarks of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a> for details.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#a54f6debe554f34455cbee81f97bb9a40">Loyc.Syntax.Precedence.CanAppearIn()</a>, and <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html#af07a82282e299b44ea73a18eac73afd9">Loyc.Syntax.Precedence.LeftContext()</a>.</p>

</div>
</div>
<a class="anchor" id="a960ac158fb2d0d01817f5a15d4adf694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly sbyte Loyc.Syntax.Precedence.Lo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lo and Hi specify the miscibility of an operator; see the remarks of <a class="el" href="structLoyc_1_1Syntax_1_1Precedence.html" title="A four-byte tuple that represents the precedence and miscibility of an operator.">Precedence</a> for details.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="ac587c783e958192a3d409fb8a973b39a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Syntax.Precedence.IsRightAssociative</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this object represents a right-associative operator such as equals (x = (y = z)), in contrast to left- associative operators such as division ((x / y) / z).</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 24 2016 09:22:26 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
