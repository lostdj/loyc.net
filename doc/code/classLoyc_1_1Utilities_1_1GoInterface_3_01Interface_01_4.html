<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Enhanced C#: Loyc.Utilities.GoInterface&lt; Interface &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<h1>Documentation moved to <a href="http://ecsharp.net/doc/code">ecsharp.net</a></h1>
<small>GitHub doesn't support HTTP redirects, so you'll be redirected in 3 seconds.</small>
<br/><br/>
<script>
setTimeout(function() {
	if (window.location.href.indexOf('http://loyc.net') == 0) {
	  window.location.href = 'http://ecsharp.net' + window.location.href.substr('http://loyc.net'.length);
	}
}, 3000);
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Utilities.html">Utilities</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Utilities_1_1GoInterface_3_01Interface_01_4.html">GoInterface< Interface ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classLoyc_1_1Utilities_1_1GoInterface_3_01Interface_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Utilities.GoInterface&lt; Interface &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface&gt; creates wrappers around objects of your choosing that implement the specified Interface, forwarding calls to methods in the wrapped object. It is inspired by the duck-typed interfaces in the Go programming language. 
 <a href="classLoyc_1_1Utilities_1_1GoInterface_3_01Interface_01_4.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Utilities/GoInterface.cs'>/Core/Loyc.Utilities/GoInterface.cs</a></li>
</ul>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p><a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface&gt; creates wrappers around objects of your choosing that implement the specified Interface, forwarding calls to methods in the wrapped object. It is inspired by the duck-typed interfaces in the Go programming language.</p>
<p>In the Go programming language, you do not say explicitly that your type implements a given interface. Instead, a type is convertable to <em>any</em> interface, just so long as it implements all the methods in the interface. This often reminds people of "duck typing" in dynamic languages such as Python or Ruby, but it is faster; in fact, Go interface calls are the same speed as virtual method calls in C++ and C#! </p>
<p>To put it in C# terms, if you have a class T... </p><pre>public class T {
    public void Foo(int x);
}</pre><p>...and an interface called "Interface"...</p>
<pre>public interface Interface {
    void Foo(int x);
}</pre><p>...then you can cast T to Interface even though T does not explicitly implement it.</p>
<pre>Interface t = new T();</pre><p>This cast can be implicit since the compiler can tell at compile time that T implements the Interface. However, you can cast any object to Interface and, at run-time, Go will determine whether it implements the Interface. </p>
<p>I asked how Go dispatch works on the "Go Nuts" google group and was pointed to two articles: </p>
<p><a href="http://research.swtch.com/2009/12/go-data-structures-interfaces.html">http://research.swtch.com/2009/12/go-data-structures-interfaces.html</a> <a href="http://www.airs.com/blog/archives/281">http://www.airs.com/blog/archives/281</a> </p>
<p>To summarize those, the first time you convert a type "T" to an interface "Interface", a vtable (virtual function table) is generated just like the kind used for virtual calls in .NET and C++. However, instead of storing the vtable in the object itself like C++ and .NET do, Go stores the vtable pointer alongside the interface pointer (i.e. an interface pointer is really two pointers). This simple but unique design allows a single object to implement an unlimited number of interfaces with overall performance that is competitive with C# and Java. </p>
<p>Unfortunately, as far as I can tell, there is no way to efficiently implement this same technique in .NET without changing the CLR itself. A virtual method table is just a list of pointers to functions; importantly, function pointers in a virtual method table are not associated with a specific object, which makes them different from .NET delegates. By not associating the vtable with a specific object, it is possible to re-use the same vtable with any number of objects (as long as they are of the same class). However, .NET delegates are associated with specific objects, so we can't use them to form a reusable vtable. </p>
<p>Even if .NET allowed delegates that are not associated with a specific object, delegate invocation on .NET is slower than virtual method invocation; why this is so is not entirely clear to me, but part of the reason may be that Microsoft decided to make delegates reference types when they should have been a simpler 8-byte value type (just bundling a function pointer with a 'this' pointer). </p>
<p>However, just a few days ago I learned that Visual Basic 9 has a very similar feature to Go called "dynamic interfaces", which pretty much lets you do as described above (albeit only in Visual Basic). So far I've heard nothing about how VB's dynamic interfaces work, but I got to thinking: how hard would it be to bring go-style interfaces to all .NET languages, and would it be possible to get good performance? </p>
<p>The technique I chose doesn't have performance as good as you would get from Go, but in exchange for a small performance hit (which I believe to be unavoidable anyway), the <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> classes provide automatic interface adaptations that you can't get in Go itself. Specifically, my <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> classes can automatically do small type conversion tasks like enlarging "int" to "long", boxing value types, and allowing return type covariance (for instance, if the wrapped method returns a "string", the Interface can return an "object".) And since <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> returns heap objects that actually implement the interface you ask for (rather than, say, an 8-byte structure imitating the Go implementation), it's very easy to use. </p>
<p>The <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> classes use .NET Reflection.Emit to generate wrapper classes in a "dynamic assembly"&ndash;basically a DLL that exists only in memory. Each wrapper class implements a single interface of your choosing, and forwards calls on that interface to an object of your choosing. </p>
<p>Given the types from above...</p>
<pre>public class T {
    public void Foo(int x);
}
public interface Interface {
    void Foo(int x);
}</pre><p>...you can use <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> to cast T to Interface like this:</p>
<pre>Interface t = <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface&gt;.From(new T());</pre><p>The first time you cast a T to Interface, <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> generates a wrapper class such as the following on-the-fly:</p>
<pre>public class T_46F3E18_46102A0 : Interface
{
    T _obj;
    public T_46F3E18_46102A0(T obj) { _obj = obj; }
    void Foo(int x) { _obj.Foo(x); }
}</pre><p>The hex numbers in the name of the type are simply handles to interface and type being wrapped, in order to guarantee no name collisions occur when you are wrapping a lot of different classes with <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>. </p>
<p>After the first cast, all future casts are fairly fast, especially if you call <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface,T&gt;.From() instead of just <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface&gt;.From(). That's because after <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface,T&gt; is fully initialized, all its From() method does is invoke a delegate that contains the following code:</p>
<pre>delegate(T obj) { return new T_46F3E18_46102A0(obj); }</pre><p>You can create wrappers with either <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface&gt; or <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface, T&gt; (note the extra type argument "T"). </p><ul>
<li>
<a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface&gt; is intended for creating wrappers when you do not know the type of the object at compile time. For example, if you have a list of objects of unknown type and you want to cast them to an interface, use this one. </li>
<li>
<a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface, T&gt; creates wrappers when you already know the type of the object at compile time. This version assumes that T itself (and not some derived class!) contains the methods you want to call. <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface, T&gt; has the disadvantage that it is unable to call methods in a derived class of T. For example, you should not use <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface, object&gt; because the object class does not contain a Foo method. </li>
</ul>
<p>If you're not sure which one to use, use <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface&gt;. If you need to adapt a large number of objects to a single interface, you should use <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface, T&gt; where possible, because it is slightly faster. <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a>&lt;Interface&gt;, in contrast, has to examine each object it is given to find out its most derived type. However, this process is optimized so that an expensive analysis is only done once per derived type, after which only a hashtable lookup is required. </p>
<p>Compared to interfaces in the Go programming language, which have a 1-word overhead for every interface pointer (the vtable pointer, which is 4 bytes in 32-bit code), <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> wrappers normally have 3 words of overhead (2 words for the wrapper's object header and 1 word for a reference to the wrapped object). Also, <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> wrapper classes are no doubt much more costly to produce (since they involve run-time code generation), which will increase your program's startup time and have a fixed memory overhead that dwarfs Go's implementation. However, once you are up-and-running with <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> wrappers, their performance should be pretty good. TODO: benchmarks </p>
<p>Note: <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> can create wrappers for value types (structures), not just classes. Such wrappers have the same memory overhead as boxed structures, which is one word less than wrappers for reference types. </p>
<p><a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> wrappers automatically forward calls to object.ToString(), object.GetHashCode() and object.Equals(), even though these methods are not technically part of the interface being wrapped. </p>
<p><a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> cannot wrap explicit interface implementations in the target class. For instance, if the target class implements IEnumerable(of T), that interface has two versions of the GetEnumerator function that differ only by return type (one returns IEnumerator and the other returns IEnumerator(of T)), so one of them must be implemented "explicitly". <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> will typically only see the version that returns IEnumerator(of T), but this is not a problem since IEnumerator(of T) is implicitly convertable to IEnumerator, so <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> can use that one method to represent either of them. In Visual Basic there is a caveat, since an explicit interface implementation is allowed to be public. In that case, <a class="el" href="classLoyc_1_1Utilities_1_1GoInterface.html" title="Mainly for internal use by the other GoInterface classes.">GoInterface</a> will only see the method's public name (not the name used in the interface). </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>Interface</em></td><td>&#160;:</td><td valign="top"><em>class</em></td><td>&#160;</td></tr>
</table>
</dl>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad560d2fe124bfa218d199fef5246ba15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad560d2fe124bfa218d199fef5246ba15"></a>
static Interface&#160;</td><td class="memItemRight" valign="bottom"><b>From&lt; T &gt;</b> (T anything)</td></tr>
<tr class="separator:ad560d2fe124bfa218d199fef5246ba15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41ef0cbd0b46d1a5049ba4b085393ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa41ef0cbd0b46d1a5049ba4b085393ff"></a>
static Interface&#160;</td><td class="memItemRight" valign="bottom"><b>ForceFrom&lt; T &gt;</b> (T anything)</td></tr>
<tr class="separator:aa41ef0cbd0b46d1a5049ba4b085393ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceeca1e413c00b24fb22c15c29106a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ceeca1e413c00b24fb22c15c29106a3"></a>
static Interface&#160;</td><td class="memItemRight" valign="bottom"><b>From&lt; T &gt;</b> (T anything, <a class="el" href="namespaceLoyc_1_1Utilities.html#a0b991347be36ec89ac569a0b7042a6fe">CastOptions</a> options)</td></tr>
<tr class="separator:a2ceeca1e413c00b24fb22c15c29106a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 24 2016 09:22:28 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
