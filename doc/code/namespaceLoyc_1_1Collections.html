<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Enhanced C#: Package Loyc.Collections</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<h1>Documentation moved to <a href="http://ecsharp.net/doc/code">ecsharp.net</a></h1>
<small>GitHub doesn't support HTTP redirects, so you'll be redirected in 3 seconds.</small>
<br/><br/>
<script>
setTimeout(function() {
	if (window.location.href.indexOf('http://loyc.net') == 0) {
	  window.location.href = 'http://ecsharp.net' + window.location.href.substr('http://loyc.net'.length);
	}
}, 3000);
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Package Loyc.Collections</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains general-purpose interfaces (Loyc.Collections.IListSource{T}, ranges, etc.), collection implementations (Loyc.Collections.DList{T}, Loyc.Collections.WeakValueDictionary{K,V}, etc.), extension methods (<a class="el" href="classLoyc_1_1Collections_1_1LCExt.html" title="Extension methods for Loyc Collection interfaces (such as IListSource{T}) and for Loyc Collection ada...">Loyc.Collections.LCExt</a>, <a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html" title="Additional extension methods for IEnumerable{T}, beyond what LINQ provides. ">Loyc.Collections.EnumerableExt</a>, etc.), helper classes (Loyc.Collections.EmptyList{T}, (Loyc.Collections.Repeated{T}, etc.), and adapter classes (Loyc.Collections.ListSlice{T}, Loyc.Collections.BufferedSequence{T}, etc.).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceLoyc_1_1Collections_1_1Impl"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLoyc_1_1Collections_1_1Impl.html">Impl</a></td></tr>
<tr class="memdesc:namespaceLoyc_1_1Collections_1_1Impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains helper classes and base classes for implementing collections (Loyc.Collections.Impl.InternalList{T}, Loyc.Collections.Impl.ListExBase{T}, Loyc.Collections.Impl.ListSourceBase{T}, etc.) Also contains the AList and CPTrie node classes, which perhaps should not be <code>public</code>...<br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1AList_3_01T_01_4.html">AList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An all-purpose list structure with the following additional features beyond what's offered by List{T}: fast insertion and deletion (O(log N)), batch insertion and deletion, observability, fast cloning, freezability, and fast splitting and joining of large collections.  <a href="classLoyc_1_1Collections_1_1AList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1AListBase_3_01K_00_01T_01_4.html">AListBase&lt; K, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the indexed tree-based data structures known as AList{T} and BList{T}.  <a href="classLoyc_1_1Collections_1_1AListBase_3_01K_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1AListBase_3_01T_01_4.html">AListBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class of AList{T} and SparseAList{T}. Most of the functionality of the two types is identical, so this class is used to share code between them.  <a href="classLoyc_1_1Collections_1_1AListBase_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1AListReverseView_3_01K_00_01T_01_4.html">AListReverseView&lt; K, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reverse view of an AList. <a href="structLoyc_1_1Collections_1_1AListReverseView_3_01K_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ArrayOf4_3_01T_01_4.html">ArrayOf4&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1ArraySlice_3_01T_01_4.html">ArraySlice&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: Provides access to a section of an array. <a href="structLoyc_1_1Collections_1_1ArraySlice_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1BDictionary_3_01K_00_01V_01_4.html">BDictionary&lt; K, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An sorted dictionary that is efficient for all operations and offers indexed access to its list of key-value pairs.  <a href="classLoyc_1_1Collections_1_1BDictionary_3_01K_00_01V_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Bijection_3_01K1_00_01K2_01_4.html">Bijection&lt; K1, K2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bijection is a one-to-one function and its inverse. It is implemented with a pair of dictionaries, one that maps K1 to K2 and another that maps K2 to K1. <a href="classLoyc_1_1Collections_1_1Bijection_3_01K1_00_01K2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1BList_3_01T_01_4.html">BList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An sorted in-memory list that is efficient for all operations and offers indexed access to its list.  <a href="classLoyc_1_1Collections_1_1BList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1BMultiMap_3_01K_00_01V_01_4.html">BMultiMap&lt; K, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An sorted dictionary that allows multiple values to be associated with a single key. Note: both keys and values must be comparable.  <a href="classLoyc_1_1Collections_1_1BMultiMap_3_01K_00_01V_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1BufferedSequence_3_01T_01_4.html">BufferedSequence&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: This class wraps an IEnumerator{T} or IEnumerable{T} into an IListSource{T}, lazily reading the sequence as <a class="el" href="classLoyc_1_1Collections_1_1BufferedSequence_3_01T_01_4.html#ace85df14b79a267416f1eb8c121752a9" title="Gets the item at the specified index, and does not throw an exception on failure.">TryGet</a> is called. <a href="classLoyc_1_1Collections_1_1BufferedSequence_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1CG.html">CG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains global functions of <a class="el" href="namespaceLoyc_1_1Collections.html" title="Contains general-purpose interfaces (Loyc.Collections.IListSource{T}, ranges, etc.), collection implementations (Loyc.Collections.DList{T}, Loyc.Collections.WeakValueDictionary{K,V}, etc.), extension methods (Loyc.Collections.LCExt, Loyc.Collections.EnumerableExt, etc.), helper classes (Loyc.Collections.EmptyList{T}, (Loyc.Collections.Repeated{T}, etc.), and adapter classes (Loyc.Collections.ListSlice{T}, Loyc.Collections.BufferedSequence{T}, etc.). ">Loyc.Collections</a> that don't belong in any specific class. <a href="classLoyc_1_1Collections_1_1CG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1CollectionAsReadOnly_3_01T_01_4.html">CollectionAsReadOnly&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: a read-only wrapper that implements ICollection(T) and IReadOnlyCollection(T), returned from LCExt.AsReadOnly{T}. <a href="classLoyc_1_1Collections_1_1CollectionAsReadOnly_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1CollectionDebugView_3_01T_01_4.html">CollectionDebugView&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper class gives a nice view of a custom collection within the debugger.  <a href="classLoyc_1_1Collections_1_1CollectionDebugView_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1CPStringTrie_3_01TValue_01_4.html">CPStringTrie&lt; TValue &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compact patricia trie that uses strings as keys. <a href="classLoyc_1_1Collections_1_1CPStringTrie_3_01TValue_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1CPTrie_3_01T_01_4.html">CPTrie&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact patricia tree class that stores keys as byte arrays. This class is intended to be use as a base class; a derived class can give meaning to the byte arrays, e.g. CPStringTrie encodes strings into byte arrays so they can be placed in the trie. <a href="classLoyc_1_1Collections_1_1CPTrie_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>CPTrieBenchmark</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>CPTrieTests</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test suite for CPStringTrie, CPByteTrie and CPIntTrie <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1CPValueCollection_3_01T_01_4.html">CPValueCollection&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides read-only access to the values of a CPTrie. <a href="classLoyc_1_1Collections_1_1CPValueCollection_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1DictionaryDebugView_3_01K_00_01V_01_4.html">DictionaryDebugView&lt; K, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Workaround for a limitation of the debugger: it doesn't support CollectionDebugView{T} when T is KeyValuePair{K,V}. This class is identical, except that T is replaced with KeyValuePair{K,V}.  <a href="classLoyc_1_1Collections_1_1DictionaryDebugView_3_01K_00_01V_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1DictionaryExt.html">DictionaryExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension methods for Dictionary{K,V} and IDictionary{K,V}. <a href="classLoyc_1_1Collections_1_1DictionaryExt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1DList.html">DList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the same as <code><a class="el" href="classLoyc_1_1Collections_1_1DList.html" title="This class is the same as DList{object} except that it also implements the IList interface. ">DList</a>{object}</code> except that it also implements the IList interface.  <a href="classLoyc_1_1Collections_1_1DList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1DList_3_01T_01_4.html">DList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compact auto-enlarging list that efficiently supports supports insertions at the beginning or end of the list.  <a href="classLoyc_1_1Collections_1_1DList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EmptyArray_3_01T_01_4.html">EmptyArray&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">EmptyArray{T}.Value lets you avoid allocating an empty array on the heap. <a href="classLoyc_1_1Collections_1_1EmptyArray_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EmptyEnumerator_3_01T_01_4.html">EmptyEnumerator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class: an empty enumerator. <a href="classLoyc_1_1Collections_1_1EmptyEnumerator_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EmptyList_3_01T_01_4.html">EmptyList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class: EmptyList{T}.Value is a read-only empty list. <a href="classLoyc_1_1Collections_1_1EmptyList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EmptySequenceException.html">EmptySequenceException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown by methods or properties that require a non-empty sequence but were provided with an empty sequence. <a href="classLoyc_1_1Collections_1_1EmptySequenceException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html">EnumerableExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional extension methods for IEnumerable{T}, beyond what LINQ provides.  <a href="classLoyc_1_1Collections_1_1EnumerableExt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumerationException.html">EnumerationException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown by an enumerator when it detects that the collection was modified after enumeration started but before it finished. <a href="classLoyc_1_1Collections_1_1EnumerationException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1EnumeratorBase_3_01T_01_4.html">EnumeratorBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class to help you implement the standard IEnumerator{T} interface. All you have to do is override MoveNext() and, when successful, set the Current property. <a href="classLoyc_1_1Collections_1_1EnumeratorBase_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html">FVList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a FVList, a so-called persistent list data structure.  <a href="structLoyc_1_1Collections_1_1FVList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1FWList_3_01T_01_4.html">FWList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FWList is the mutable variant of the FVList data structure.  <a href="classLoyc_1_1Collections_1_1FWList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IAdd_3_01in_01T_01_4.html">IAdd&lt; in T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for depositing items. Includes only an Add(T) method. <a href="interfaceLoyc_1_1Collections_1_1IAdd_3_01in_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IAddRange_3_01T_01_4.html">IAddRange&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface typically implemented alongside ICollection{T}, for collection types that can add multiple items in one method call. <a href="interfaceLoyc_1_1Collections_1_1IAddRange_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IArray_3_01T_01_4.html">IArray&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface models the capabilities of an array: getting and setting elements by index, but not adding or removing elements. <a href="interfaceLoyc_1_1Collections_1_1IArray_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IAutoCreatePool_3_01in_01TKey_00_01out_01TValue_01_4.html">IAutoCreatePool&lt; in TKey, out TValue &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pool of objects in which an object is automatically created when requested by its key. <a href="interfaceLoyc_1_1Collections_1_1IAutoCreatePool_3_01in_01TKey_00_01out_01TValue_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IAutoSizeArray_3_01T_01_4.html">IAutoSizeArray&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An auto-sizing array is a list structure that allows you to modify the element at any index, including indices that don't yet exist; the collection automatically adds missing indices. <a href="interfaceLoyc_1_1Collections_1_1IAutoSizeArray_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IBinumerable_3_01T_01_4.html">IBinumerable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a collection that can return IBinumerator{T}s pointing to the beginning and end of the collection. <a href="interfaceLoyc_1_1Collections_1_1IBinumerable_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IBinumerator_3_01T_01_4.html">IBinumerator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the "enumerator" concept to allow backward enumeration. <a href="interfaceLoyc_1_1Collections_1_1IBinumerator_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IBRange_3_01out_01T_01_4.html">IBRange&lt; out T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bidirectional range. Allows you to read or remove the first or last element in a range. <a href="interfaceLoyc_1_1Collections_1_1IBRange_3_01out_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IBRangeEx_3_01R_00_01T_01_4.html">IBRangeEx&lt; R, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bidirectional range that can perform operations such as intersection and overlap tests on pairs of ranges of the same type. <a href="interfaceLoyc_1_1Collections_1_1IBRangeEx_3_01R_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IBRangeEx_3_01T_01_4.html">IBRangeEx&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bidirectional range that can perform operations such as intersection and overlap tests on pairs of ranges. <a href="interfaceLoyc_1_1Collections_1_1IBRangeEx_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ICharSource.html">ICharSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read-only list of characters plus a <a class="el" href="interfaceLoyc_1_1Collections_1_1ICharSource.html#a6015c7a99af81fe0de9fcc67e43a2768" title="Returns a substring from the character source. If some of the requested characters are past the end o...">Slice(int,int)</a> method. <a href="interfaceLoyc_1_1Collections_1_1ICharSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ICollectionAndReadOnly_3_01T_01_4.html">ICollectionAndReadOnly&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface combines the original ICollection{T} with IReadOnlyCollection{T}. It exists for the same reason as IListAndListSource{T}, to fix ambiguity errors. <a href="interfaceLoyc_1_1Collections_1_1ICollectionAndReadOnly_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ICollectionEx_3_01T_01_4.html">ICollectionEx&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface combines the original ICollection(T) interface with IReadOnlyCollection(T), ISinkCollection(T), and IAddRange(T), a convenient way to implement all three.  <a href="interfaceLoyc_1_1Collections_1_1ICollectionEx_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ICount.html">ICount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the Count property found in nearly all collection interfaces. <a href="interfaceLoyc_1_1Collections_1_1ICount.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IDeque_3_01T_01_4.html">IDeque&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a double-ended queue that allows items to be added or removed at the beginning or end. <a href="interfaceLoyc_1_1Collections_1_1IDeque_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IFRange_3_01out_01T_01_4.html">IFRange&lt; out T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward range. Allows you to read the first element from the range or skip it. The forward range lays the foundation for IBRange{T} and IRange{T}. <a href="interfaceLoyc_1_1Collections_1_1IFRange_3_01out_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IIsEmpty.html">IIsEmpty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the IsEmpty property that tells you if a collection is empty. <a href="interfaceLoyc_1_1Collections_1_1IIsEmpty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListAndListSource_3_01T_01_4.html">IListAndListSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface combines the original IList{T} interface with its "source" (read-only) component interfaces, including IReadOnlyList{T}, plus IListSource{T}. <a href="interfaceLoyc_1_1Collections_1_1IListAndListSource_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListEx_3_01T_01_4.html">IListEx&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface combines the original IList(T) interface with several IListSource(T), ISinkList(T), IArray(T) and several additional methods (e.g. RemoveAll, InsertRange).  <a href="interfaceLoyc_1_1Collections_1_1IListEx_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListRangeMethods_3_01T_01_4.html">IListRangeMethods&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface typically implemented alongside IList{T} for collection types that can add or remove multiple items in one method call. <a href="interfaceLoyc_1_1Collections_1_1IListRangeMethods_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource_3_01out_01T_01_4.html">IListSource&lt; out T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read-only list indexed by an integer. <a href="interfaceLoyc_1_1Collections_1_1IListSource_3_01out_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IMBinumerator_3_01T_01_4.html">IMBinumerator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable bidirectional enumerator interface. Please note that the "Remove" method always moves to the next item, even though the Binumerator is capable of moving backward. <a href="interfaceLoyc_1_1Collections_1_1IMBinumerator_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IMBRange_3_01T_01_4.html">IMBRange&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable bidirectional range. <a href="interfaceLoyc_1_1Collections_1_1IMBRange_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IMEnumerator_3_01T_01_4.html">IMEnumerator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable enumerator interface. Provides a "Remove" method like Java iterators have, and allows you to modify the current item. <a href="interfaceLoyc_1_1Collections_1_1IMEnumerator_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IMFRange_3_01T_01_4.html">IMFRange&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable forward range. <a href="interfaceLoyc_1_1Collections_1_1IMFRange_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IMRange_3_01T_01_4.html">IMRange&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable random-access range. <a href="interfaceLoyc_1_1Collections_1_1IMRange_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1IndexedAList_3_01T_01_4.html">IndexedAList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple wrapper around AList that includes an AListIndexer{K,T} that can be used to find items relatively quickly in a large list. When an index is built and the list is large, it accelerates IndexOf(item), Contains(item) and Remove(item).  <a href="classLoyc_1_1Collections_1_1IndexedAList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1INegArray_3_01T_01_4.html">INegArray&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface models the capabilities of an array: getting and setting elements by index, but not adding or removing elements. This interface is the counterpart to IListSource{T} for lists whose minimum index is not (necessarily) zero.  <a href="interfaceLoyc_1_1Collections_1_1INegArray_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1INegAutoSizeArray_3_01T_01_4.html">INegAutoSizeArray&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An auto-sizing array is a list structure that allows you to modify the element at any index, including indexes that don't yet exist; the collection automatically adds missing indexes. <a href="interfaceLoyc_1_1Collections_1_1INegAutoSizeArray_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1INegDeque_3_01T_01_4.html">INegDeque&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Deque that supports negative indexes. In this kind of Deque, pushing and popping elements does not affect the indexes of the other elements in the collection. <a href="interfaceLoyc_1_1Collections_1_1INegDeque_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1INegListSource_3_01T_01_4.html">INegListSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface is the counterpart to IListSource{T} for lists whose minimum index is not (necessarily) zero. <a href="interfaceLoyc_1_1Collections_1_1INegListSource_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1INotifyListChanging_3_01T_01_4.html">INotifyListChanging&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the <a class="el" href="interfaceLoyc_1_1Collections_1_1INotifyListChanging_3_01T_01_4.html#a5371a11becb3c1c655b33b5d52a2af32" title="Occurs when the collection associated with this interface is about to change.">ListChanging</a> event that notifies listeners of dynamic changes to an indexed list, such as when items get added and removed or the whole list is refreshed.  <a href="interfaceLoyc_1_1Collections_1_1INotifyListChanging_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1InvertibleSet_3_01T_01_4.html">InvertibleSet&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable set that can be inverted. For example, an <code>InvertibleSet&lt;int&gt;</code> could contain "everything except 4 and 10", or it could contain a positive set such as "1, 2, and 3". <a href="classLoyc_1_1Collections_1_1InvertibleSet_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>InvertibleSetTests</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IPop_3_01T_01_4.html">IPop&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a collection that produces a sequence of items, and can return the next item without popping it (the Peek operation). <a href="interfaceLoyc_1_1Collections_1_1IPop_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IPush_3_01T_01_4.html">IPush&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a collection that accepts a sequence of items. <a href="interfaceLoyc_1_1Collections_1_1IPush_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IQueue_3_01T_01_4.html">IQueue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a FIFO (first-in-first-out) queue. <a href="interfaceLoyc_1_1Collections_1_1IQueue_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IRange_3_01out_01T_01_4.html">IRange&lt; out T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random-access range, also known as a "slice". Allows you to narrow down the range like IBRange{T} does, and also provides random access via IListSource{T}. <a href="interfaceLoyc_1_1Collections_1_1IRange_3_01out_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IRangeEx_3_01R_00_01T_01_4.html">IRangeEx&lt; R, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random-access range that can perform operations such as intersection and overlap tests on pairs of ranges of the same type. <a href="interfaceLoyc_1_1Collections_1_1IRangeEx_3_01R_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IRangeEx_3_01T_01_4.html">IRangeEx&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random-access range that can perform operations such as intersection and overlap tests on pairs of ranges. <a href="interfaceLoyc_1_1Collections_1_1IRangeEx_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ISetImm_3_01T_01_4.html">ISetImm&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable set that supports numerous set operations. <a href="interfaceLoyc_1_1Collections_1_1ISetImm_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ISetImm_3_01T_00_01SetT_01_4.html">ISetImm&lt; T, SetT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable set of type SetT with elements of type T. <a href="interfaceLoyc_1_1Collections_1_1ISetImm_3_01T_00_01SetT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ISetOperations_3_01in_01T_00_01in_01InSetT_00_01out_01OutSetT_01_4.html">ISetOperations&lt; in T, in InSetT, out OutSetT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ISetOperations_3_01in_01T_00_01SetT_01_4.html">ISetOperations&lt; in T, SetT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set-combining operations: With, Without, Union, Intersect, Except, Xor. <a href="interfaceLoyc_1_1Collections_1_1ISetOperations_3_01in_01T_00_01SetT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><b>ISetTests&lt; SetT &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set testing operations.<br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ISinkArray_3_01T_01_4.html">ISinkArray&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a write-only array. <a href="interfaceLoyc_1_1Collections_1_1ISinkArray_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ISinkCollection_3_01T_01_4.html">ISinkCollection&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a write-only collection: you can modify it, but you cannot learn what it contains. <a href="interfaceLoyc_1_1Collections_1_1ISinkCollection_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ISinkList_3_01T_01_4.html">ISinkList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a write-only indexable list class. <a href="interfaceLoyc_1_1Collections_1_1ISinkList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ISparseList_3_01T_01_4.html">ISparseList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a sparse list that allows insertion and removal of items and empty spaces. In a sparse list, some spaces can be "clear" meaning that they have no value. <a href="interfaceLoyc_1_1Collections_1_1ISparseList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ISparseListEx_3_01T_01_4.html">ISparseListEx&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse list that supports additional methods including InsertRange(int, ISparseListSource{T}). <a href="interfaceLoyc_1_1Collections_1_1ISparseListEx_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1ISparseListSource_3_01T_01_4.html">ISparseListSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a read-only indexed list in which parts of the index space may be unused or "clear". <a href="interfaceLoyc_1_1Collections_1_1ISparseListSource_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceLoyc_1_1Collections_1_1IStack_3_01T_01_4.html">IStack&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a LIFO (last-in-first-out) stack. <a href="interfaceLoyc_1_1Collections_1_1IStack_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1KeyAlreadyExistsException.html">KeyAlreadyExistsException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown by dictionary objects when they are asked to "add" a key-value pair that already exists. <a href="classLoyc_1_1Collections_1_1KeyAlreadyExistsException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1KeyCollection_3_01TKey_00_01TValue_01_4.html">KeyCollection&lt; TKey, TValue &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: this is a read-only collection of Keys read from a generic IDictionary. It is a modified version of Dictionary{TKey, TValue}.KeyCollection from the Mono project, changed to use IDictionary instead of Dictionary. <a href="classLoyc_1_1Collections_1_1KeyCollection_3_01TKey_00_01TValue_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1LCExt.html">LCExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension methods for <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> Collection interfaces (such as IListSource{T}) and for <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> Collection adapters (such as AsReadOnly{T}, which returns a CollectionAsReadOnly{T} adapter.) <a href="classLoyc_1_1Collections_1_1LCExt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1LCInterfaces.html">LCInterfaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains extension methods that are provided as part of various <a class="el" href="namespaceLoyc_1_1Collections.html" title="Contains general-purpose interfaces (Loyc.Collections.IListSource{T}, ranges, etc.), collection implementations (Loyc.Collections.DList{T}, Loyc.Collections.WeakValueDictionary{K,V}, etc.), extension methods (Loyc.Collections.LCExt, Loyc.Collections.EnumerableExt, etc.), helper classes (Loyc.Collections.EmptyList{T}, (Loyc.Collections.Repeated{T}, etc.), and adapter classes (Loyc.Collections.ListSlice{T}, Loyc.Collections.BufferedSequence{T}, etc.). ">Loyc.Collections</a> interfaces. For example, it provides methods such as IndexOf(), Contains() and CopyTo(), that the traditional ICollection{T} and IList{T} interfaces require the author to write himself.  <a href="classLoyc_1_1Collections_1_1LCInterfaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1LinqToCollections.html">LinqToCollections</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Work in progress. This class will enhance LINQ-to-Objects with type-preserving and/or higher-performance extension methods.  <a href="classLoyc_1_1Collections_1_1LinqToCollections.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListAsListSource_3_01T_01_4.html">ListAsListSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type returned from LCExt.AsListSource{T}.  <a href="classLoyc_1_1Collections_1_1ListAsListSource_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1ListChangeInfo_3_01T_01_4.html">ListChangeInfo&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information about how a collection is about to change. <a href="structLoyc_1_1Collections_1_1ListChangeInfo_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListExt.html">ListExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension methods and helper methods for List{T}, IList{T}, IReadOnlyList{T}, arrays, IListSource{T}, and for related mutable interfaces such as IArray{T}.  <a href="classLoyc_1_1Collections_1_1ListExt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1ListSlice_3_01T_01_4.html">ListSlice&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: a wrapper of a list that provides a view of a range of elements. Objects of this type are returned from ListExt.Slice{T}  <a href="structLoyc_1_1Collections_1_1ListSlice_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListSourceAsList_3_01T_01_4.html">ListSourceAsList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: a read-only wrapper that implements IList(T) and IListSource(T), returned from LCExt.AsList{T}. <a href="classLoyc_1_1Collections_1_1ListSourceAsList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListSourceAsSparse_3_01T_01_4.html">ListSourceAsSparse&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter from IListSource{T} to ISparseListSource{T}. <a href="classLoyc_1_1Collections_1_1ListSourceAsSparse_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ListSourceDebugView_3_01T_01_4.html">ListSourceDebugView&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper class gives a nice view of a custom collection within the debugger.  <a href="classLoyc_1_1Collections_1_1ListSourceDebugView_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1Map_3_01K_00_01V_01_4.html">Map&lt; K, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable dictionary.  <a href="classLoyc_1_1Collections_1_1Map_3_01K_00_01V_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1MapOrMMap_3_01K_00_01V_01_4.html">MapOrMMap&lt; K, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class that contains code shared between Map{K,V} and MMap{K,V}. <a href="classLoyc_1_1Collections_1_1MapOrMMap_3_01K_00_01V_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1MMap_3_01K_00_01V_01_4.html">MMap&lt; K, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dictionary class built on top of <code>InternalSet&lt;KeyValuePair&lt;K,V&gt;&gt;</code>.  <a href="classLoyc_1_1Collections_1_1MMap_3_01K_00_01V_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1MSet_3_01T_01_4.html">MSet&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable set. <a href="classLoyc_1_1Collections_1_1MSet_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1NegList_3_01T_01_4.html">NegList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: provides a view of an IList{T} in which the Count is the same, but the minimum index is not necessarily zero. Returned from LCExt.NegView{T}(IList{T},int).  <a href="structLoyc_1_1Collections_1_1NegList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1NegListSlice_3_01T_01_4.html">NegListSlice&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: a random-access range for a slice of an INegListSource{T}. <a href="structLoyc_1_1Collections_1_1NegListSlice_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1NegListSource_3_01T_01_4.html">NegListSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: provides a view of an IListSource{T} in which the Count is the same, but the minimum index is not necessarily zero. Returned from LCExt.NegView{T}(IListSource{T},int).  <a href="structLoyc_1_1Collections_1_1NegListSource_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1NestedEnumerable_3_01Frame_00_01T_01_4.html">NestedEnumerable&lt; Frame, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type. You pass a cloneable <code>Frame</code> object to the constructor, and then a copy of this <code>Frame</code> is used to construct a new NestedEnumerator{Frame,T} each time the user calls GetEnumerator. <a href="structLoyc_1_1Collections_1_1NestedEnumerable_3_01Frame_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1NestedEnumerator_3_01Frame_00_01T_01_4.html">NestedEnumerator&lt; Frame, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class. An enumerator that helps enumerate tree data structures. It maintains a virtual call stack that avoids the performance hit of using nested "yield return" statements in C#. <a href="structLoyc_1_1Collections_1_1NestedEnumerator_3_01Frame_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1NumRange_3_01Num_00_01Math_01_4.html">NumRange&lt; Num, Math &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a range of integers of a specified data type. <a href="structLoyc_1_1Collections_1_1NumRange_3_01Num_00_01Math_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1RangeEnumerator_3_01R_00_01T_01_4.html">RangeEnumerator&lt; R, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct: enumerates through a forward range (IFRange{T}), calling the range methods through R instead of through IFRange{T}.  <a href="structLoyc_1_1Collections_1_1RangeEnumerator_3_01R_00_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1RangeEnumerator_3_01T_01_4.html">RangeEnumerator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct: enumerates through a forward range (IFRange{T}). <a href="structLoyc_1_1Collections_1_1RangeEnumerator_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1RangeExt.html">RangeExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension/helper methods for ranges. <a href="classLoyc_1_1Collections_1_1RangeExt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ReadOnlyAsCollection_3_01T_01_4.html">ReadOnlyAsCollection&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read-only wrapper that implements ICollection(T) and ISource(T), returned from LCExt.AsCollection{T}  <a href="classLoyc_1_1Collections_1_1ReadOnlyAsCollection_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Repeated_3_01T_01_4.html">Repeated&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct. A sequence that stores one value, but acts like a list in which that value is repeated a specified number of times. Returned from Range.Repeat{T}. <a href="structLoyc_1_1Collections_1_1Repeated_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1ReverseBinumerator_3_01T_01_4.html">ReverseBinumerator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: a IBinumerator{T} that swaps the MoveNext() and MovePrev() methods. <a href="structLoyc_1_1Collections_1_1ReverseBinumerator_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1ReversedList_3_01T_01_4.html">ReversedList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: a reversed of an IList{T}. TODO: unit tests. <a href="structLoyc_1_1Collections_1_1ReversedList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ReversedListSource_3_01T_01_4.html">ReversedListSource&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: reversed view of IListSource{T} returned from LCExt.Reverse{T}. <a href="classLoyc_1_1Collections_1_1ReversedListSource_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>RVListTests</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>RWListTests</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1SelectListSource_3_01T_00_01TResult_01_4.html">SelectListSource&lt; T, TResult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class: provides a modified view of an IListSource by transforming each element on-demand. Objects of this type are returned from LCExt.Select{T,TResult}(IListSource{T},Func{T,TResult})  <a href="classLoyc_1_1Collections_1_1SelectListSource_3_01T_00_01TResult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1SelectNegLists_3_01T_01_4.html">SelectNegLists&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: provides a view of an IList{T} in which element [i] is a NegList{T} N such that N[0] refers to element [i] in the original list. See LCExt.NegLists{T}(IList{T}) for more information.  <a href="classLoyc_1_1Collections_1_1SelectNegLists_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1SelectNegListSources_3_01T_01_4.html">SelectNegListSources&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: provides view of an IListSource{T} in which element [i] is a NegListSource{T} N such that N[0] refers to element [i] in the original list. See LCExt.NegLists{T}(IListSource{T}) for more information.  <a href="classLoyc_1_1Collections_1_1SelectNegListSources_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Set_3_01T_01_4.html">Set&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable set. <a href="structLoyc_1_1Collections_1_1Set_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1SimpleCache_3_01T_01_4.html">SimpleCache&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cache designed to save memory by sharing instances of identical strings and other immutable objects. <a href="classLoyc_1_1Collections_1_1SimpleCache_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>SimpleCacheTests</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1Slice___3_01T_01_4.html">Slice_&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: a random-access range for a slice of an IListSource{T}. <a href="structLoyc_1_1Collections_1_1Slice___3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1SparseAList_3_01T_01_4.html">SparseAList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse A-List that implements ISparseList{T}. <a href="classLoyc_1_1Collections_1_1SparseAList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1StringSlice.html">StringSlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random-access slice of System.String. <a href="structLoyc_1_1Collections_1_1StringSlice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1UpCastListSource_3_01T_00_01TOut_01_4.html">UpCastListSource&lt; T, TOut &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for treating a collection of a derived type as a collection of a base type or interface. <a href="classLoyc_1_1Collections_1_1UpCastListSource_3_01T_00_01TOut_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1UpCastSource_3_01T_00_01TOut_01_4.html">UpCastSource&lt; T, TOut &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for treating a collection of a derived type as a collection of a base type or interface. <a href="classLoyc_1_1Collections_1_1UpCastSource_3_01T_00_01TOut_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1ValueCollection_3_01TKey_00_01TValue_01_4.html">ValueCollection&lt; TKey, TValue &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter: this is a read-only collection of Values read from a generic IDictionary. It is a modified version of <code>Dictionary{TKey, TValue}.ValueCollection</code> from the Mono project, changed to use IDictionary instead of Dictionary.  <a href="classLoyc_1_1Collections_1_1ValueCollection_3_01TKey_00_01TValue_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html">VList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VList represents a reference to a reverse-order FVList.  <a href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html">VListBlock&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VListBlock implements the core functionality of FVList, VList, FWList and WList. It is not intended to be used directly.  <a href="classLoyc_1_1Collections_1_1VListBlock_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlockArray_3_01T_01_4.html">VListBlockArray&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of VListBlock(of T) that contains an array. It is always initialized with at least one item, and items cannot be removed unless the list is mutable.  <a href="classLoyc_1_1Collections_1_1VListBlockArray_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1VListBlockOfTwo_3_01T_01_4.html">VListBlockOfTwo&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tail of a VList contains only one or two items. To improve efficiency slightly, these two-item lists are represented by a VListBlockOfTwo, which is more compact than VListBlockArray. <a href="classLoyc_1_1Collections_1_1VListBlockOfTwo_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>VListTests</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1WeakKeyComparer_3_01T_01_4.html">WeakKeyComparer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares objects of the given type or WeakKeyReferences to them for equality based on the given comparer. Note that we can only implement IEqualityComparer{T} for T = object as there is no other common base between T and WeakKeyReference{T}. We need a single comparer to handle both types because we don't want to allocate a new weak reference for every lookup. <a href="classLoyc_1_1Collections_1_1WeakKeyComparer_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1WeakKeyDictionary_3_01TKey_00_01TValue_01_4.html">WeakKeyDictionary&lt; TKey, TValue &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dictionary with weak keys. <a href="classLoyc_1_1Collections_1_1WeakKeyDictionary_3_01TKey_00_01TValue_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1WeakKeyReference_3_01T_01_4.html">WeakKeyReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a weak reference to an object of the given type to be used in a WeakDictionary along with the given comparer. <a href="classLoyc_1_1Collections_1_1WeakKeyReference_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1WeakValueDictionary_3_01K_00_01V_01_4.html">WeakValueDictionary&lt; K, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dictionary in which the values are weak. When a value has been garbage- collected, the dictionary acts as if the key is not present (except the Remove() method, which saves time by not checking whether the value is dead.)  <a href="classLoyc_1_1Collections_1_1WeakValueDictionary_3_01K_00_01V_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1WList_3_01T_01_4.html">WList&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">WList is the mutable variant of the VList data structure.  <a href="classLoyc_1_1Collections_1_1WList_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1WListBase_3_01T_01_4.html">WListBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared base class of FWList and WList. <a href="classLoyc_1_1Collections_1_1WListBase_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Collections_1_1WListProtected_3_01T_01_4.html">WListProtected&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">WList implementation in which the WList operations are only accessible to a derived class. <a href="classLoyc_1_1Collections_1_1WListProtected_3_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>WListTests</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab3f241a3b553681db7ce9ce14147e4ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4ee">AListOperation</a> { <br />
&#160;&#160;<a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eea2d67a16bc732d3b6a4a245d1a866996c">AListOperation.Retrieve</a> = 0, 
<a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eea22f12efabdd21ae885a5fa4cc04c9cdc">AListOperation.ReplaceIfPresent</a> = 1, 
<a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eea1063e38cb53d94d386f21227fcd84717">AListOperation.Remove</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">AListOperation.Add</a> = 3, 
<a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeabbbe4763739c476985364059d62b8153">AListOperation.AddOrReplace</a> = 4, 
<a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eea9ed5e57327e6a026f97d80a241955516">AListOperation.AddIfNotPresent</a> = 5, 
<br />
&#160;&#160;<a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eea10b5a86a2450131a5ed04bd2a160c8cd">AListOperation.AddOrThrow</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:ab3f241a3b553681db7ce9ce14147e4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the way an add operation (such as BList{T}.Do should behave when an item being added to a set or list is a duplicate of an item that is already present, or when the key of a key-value pair being added to a dictionary is a duplicate of a key that is already present in the dictionary. <a href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4ee">More...</a><br /></td></tr>
<tr class="separator:ab3f241a3b553681db7ce9ce14147e4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ffc4d7615f186f5aa815a344723f35"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLoyc_1_1Collections.html#af0ffc4d7615f186f5aa815a344723f35">XfAction</a> { <br />
&#160;&#160;<a class="el" href="namespaceLoyc_1_1Collections.html#af0ffc4d7615f186f5aa815a344723f35a3e679cff5b3a6f6f8f32aead541a0a12">XfAction.Drop</a>, 
<a class="el" href="namespaceLoyc_1_1Collections.html#af0ffc4d7615f186f5aa815a344723f35a02bce93bff905887ad2233110bf9c49e">XfAction.Keep</a>, 
<a class="el" href="namespaceLoyc_1_1Collections.html#af0ffc4d7615f186f5aa815a344723f35af4ec5f57bd4d31b803312d873be40da9">XfAction.Change</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceLoyc_1_1Collections.html#af0ffc4d7615f186f5aa815a344723f35a7020426cfb0a204051be4b3053d2acc8">XfAction.Repeat</a>
<br />
 }</td></tr>
<tr class="memdesc:af0ffc4d7615f186f5aa815a344723f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values that can be returned by the VListTransformer function that the user passes to the Transform method in FVList, VList, FWList or WList.  <a href="namespaceLoyc_1_1Collections.html#af0ffc4d7615f186f5aa815a344723f35">More...</a><br /></td></tr>
<tr class="separator:af0ffc4d7615f186f5aa815a344723f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac2ada228d258f5c2a0e33fb6275a0c5b"><td class="memItemLeft" align="right" valign="top">delegate <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLoyc_1_1Collections.html#ac2ada228d258f5c2a0e33fb6275a0c5b">ListChangingHandler&lt; T &gt;</a> (IListSource&lt; T &gt; sender, ListChangeInfo&lt; T &gt; args)</td></tr>
<tr class="memdesc:ac2ada228d258f5c2a0e33fb6275a0c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the method that handles the INotifyListChanging{T}.ListChanging event. <a href="#ac2ada228d258f5c2a0e33fb6275a0c5b">More...</a><br /></td></tr>
<tr class="separator:ac2ada228d258f5c2a0e33fb6275a0c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fa73bd45aaa73f658f228eb2619f9a"><td class="memItemLeft" align="right" valign="top">delegate <a class="el" href="namespaceLoyc_1_1Collections.html#af0ffc4d7615f186f5aa815a344723f35">XfAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLoyc_1_1Collections.html#aa7fa73bd45aaa73f658f228eb2619f9a">VListTransformer&lt; T &gt;</a> (int i, ref T item)</td></tr>
<tr class="memdesc:aa7fa73bd45aaa73f658f228eb2619f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-supplied list transformer function. <a href="#aa7fa73bd45aaa73f658f228eb2619f9a">More...</a><br /></td></tr>
<tr class="separator:aa7fa73bd45aaa73f658f228eb2619f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains general-purpose interfaces (Loyc.Collections.IListSource{T}, ranges, etc.), collection implementations (Loyc.Collections.DList{T}, Loyc.Collections.WeakValueDictionary{K,V}, etc.), extension methods (<a class="el" href="classLoyc_1_1Collections_1_1LCExt.html" title="Extension methods for Loyc Collection interfaces (such as IListSource{T}) and for Loyc Collection ada...">Loyc.Collections.LCExt</a>, <a class="el" href="classLoyc_1_1Collections_1_1EnumerableExt.html" title="Additional extension methods for IEnumerable{T}, beyond what LINQ provides. ">Loyc.Collections.EnumerableExt</a>, etc.), helper classes (Loyc.Collections.EmptyList{T}, (Loyc.Collections.Repeated{T}, etc.), and adapter classes (Loyc.Collections.ListSlice{T}, Loyc.Collections.BufferedSequence{T}, etc.). </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ab3f241a3b553681db7ce9ce14147e4ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4ee">Loyc.Collections.AListOperation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the way an add operation (such as BList{T}.Do should behave when an item being added to a set or list is a duplicate of an item that is already present, or when the key of a key-value pair being added to a dictionary is a duplicate of a key that is already present in the dictionary.</p>
<p>All the "add" operations are deliberately listed last, so that AListBase{K,T}.DoSingleOperation can use a greater-than operator to figure out whether an item may be added or not.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab3f241a3b553681db7ce9ce14147e4eea2d67a16bc732d3b6a4a245d1a866996c"></a>Retrieve&#160;</td><td class="fielddoc">
<p>Default operation. The item with the specified key will be retrieved. The tree will not be modified.</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab3f241a3b553681db7ce9ce14147e4eea22f12efabdd21ae885a5fa4cc04c9cdc"></a>ReplaceIfPresent&#160;</td><td class="fielddoc">
<p>Replace an existing item/key if present, or do nothing if there is no matching item/key.</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab3f241a3b553681db7ce9ce14147e4eea1063e38cb53d94d386f21227fcd84717"></a>Remove&#160;</td><td class="fielddoc">
<p>Remove the item with the specified key if present.</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc">
<p>A new item will be added unconditionally, without affecting existing elements, in no particular order with respect to existing items that have the same key.</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab3f241a3b553681db7ce9ce14147e4eeabbbe4763739c476985364059d62b8153"></a>AddOrReplace&#160;</td><td class="fielddoc">
<p>A new item will replace an item that has the same key. If the collection already contains multiple instances of the item/key, the instance to be replaced is undefined.</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab3f241a3b553681db7ce9ce14147e4eea9ed5e57327e6a026f97d80a241955516"></a>AddIfNotPresent&#160;</td><td class="fielddoc">
<p>A new item will be added if its key doesn't match an existing element. If the item already exists, it is not replaced.</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab3f241a3b553681db7ce9ce14147e4eea10b5a86a2450131a5ed04bd2a160c8cd"></a>AddOrThrow&#160;</td><td class="fielddoc">
<p>The item will be added if its key is not already present, but <a class="el" href="classLoyc_1_1Collections_1_1KeyAlreadyExistsException.html" title="An exception thrown by dictionary objects when they are asked to &quot;add&quot; a key-value pair that already ...">KeyAlreadyExistsException</a> or InvalidOperationException will be thrown if the new item is equal to an existing element. If this exception occurs during an AddRange() operation, some of the items may have already been added successfully, and the changes will not be rolled back unless otherwise specified in the documentation of the method that performs the add operation.</p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="af0ffc4d7615f186f5aa815a344723f35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceLoyc_1_1Collections.html#af0ffc4d7615f186f5aa815a344723f35">Loyc.Collections.XfAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values that can be returned by the VListTransformer function that the user passes to the Transform method in FVList, VList, FWList or WList. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af0ffc4d7615f186f5aa815a344723f35a3e679cff5b3a6f6f8f32aead541a0a12"></a>Drop&#160;</td><td class="fielddoc">
<p>Do not include the item in the output list</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af0ffc4d7615f186f5aa815a344723f35a02bce93bff905887ad2233110bf9c49e"></a>Keep&#160;</td><td class="fielddoc">
<p>Include the original item in the output list</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af0ffc4d7615f186f5aa815a344723f35af4ec5f57bd4d31b803312d873be40da9"></a>Change&#160;</td><td class="fielddoc">
<p>Include the modified item in the output list</p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af0ffc4d7615f186f5aa815a344723f35a7020426cfb0a204051be4b3053d2acc8"></a>Repeat&#160;</td><td class="fielddoc">
<p>Include the modified item in the output, and transform it again</p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac2ada228d258f5c2a0e33fb6275a0c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate <a class="el" href="structLoyc_1_1void.html">void</a> Loyc.Collections.ListChangingHandler&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IListSource&lt; T &gt;&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ListChangeInfo&lt; T &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the method that handles the INotifyListChanging{T}.ListChanging event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>The collection that changed.</td></tr>
    <tr><td class="paramname">args</td><td>Information about the change.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7fa73bd45aaa73f658f228eb2619f9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate <a class="el" href="namespaceLoyc_1_1Collections.html#af0ffc4d7615f186f5aa815a344723f35">XfAction</a> Loyc.Collections.VListTransformer&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-supplied list transformer function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>An item from the FVList or VList</td></tr>
    <tr><td class="paramname">i</td><td>Index of the item</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See the documentation of FVList.Transform() for instructions and possible return values.</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 24 2016 09:22:16 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
