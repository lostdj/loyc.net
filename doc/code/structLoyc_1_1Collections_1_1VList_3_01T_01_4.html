<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Enhanced C#: Loyc.Collections.VList&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<h1>Documentation moved to <a href="http://ecsharp.net/doc/code">ecsharp.net</a></h1>
<small>GitHub doesn't support HTTP redirects, so you'll be redirected in 3 seconds.</small>
<br/><br/>
<script>
setTimeout(function() {
	if (window.location.href.indexOf('http://loyc.net') == 0) {
	  window.location.href = 'http://ecsharp.net' + window.location.href.substr('http://loyc.net'.length);
	}
}, 3000);
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Collections.html">Collections</a></li><li class="navelem"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html">VList< T ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Nested classes</a> &#124;
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structLoyc_1_1Collections_1_1VList_3_01T_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Collections.VList&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>VList represents a reference to a reverse-order FVList.  
 <a href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Collections/VLists/VList.cs'>/Core/Loyc.Collections/VLists/VList.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Collections.VList&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structLoyc_1_1Collections_1_1VList_3_01T_01_4.png" usemap="#Loyc.Collections.VList&lt; T &gt;_map" alt=""/>
  <map id="Loyc.Collections.VList&lt; T &gt;_map" name="Loyc.Collections.VList&lt; T &gt;_map">
<area href="interfaceLoyc_1_1Collections_1_1IListAndListSource_3_01T_01_4.html" title="This interface combines the original IList{T} interface with its "source" (read-only) component inter..." alt="Loyc.Collections.IListAndListSource&lt; T &gt;" shape="rect" coords="289,112,568,136"/>
<area href="interfaceLoyc_1_1ICloneable_3_01out_01T_01_4.html" title="Interface for types that can duplicate themselves." alt="Loyc.ICloneable&lt; out T &gt;" shape="rect" coords="578,112,857,136"/>
<area href="interfaceLoyc_1_1Collections_1_1IListSource_3_01out_01T_01_4.html" title="A read-only list indexed by an integer." alt="Loyc.Collections.IListSource&lt; out T &gt;" shape="rect" coords="289,56,568,80"/>
<area href="interfaceLoyc_1_1Collections_1_1ICollectionAndReadOnly_3_01T_01_4.html" title="This interface combines the original ICollection{T} with IReadOnlyCollection{T}. It exists for the sa..." alt="Loyc.Collections.ICollectionAndReadOnly&lt; T &gt;" shape="rect" coords="722,56,1001,80"/>
<area href="structLoyc_1_1Collections_1_1VList_3_01T_01_4_1_1Enumerator.html" title="Enumerates through a VList from index 0 up to index Count-1. " alt="Loyc.Collections.VList&lt; T &gt;.Enumerator" shape="rect" coords="578,224,857,248"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>VList represents a reference to a reverse-order FVList. </p>
<p>An <a href="http://www.codeproject.com/Articles/26171/VList-data-structures-in-C">article</a> is available online about the VList data types. </p>
<p>The VList is a persistent list data structure described in Phil Bagwell's 2002 paper "Fast Functional Lists, Hash-Lists, Deques and Variable Length
Arrays". Originally, this type was called RVList because it works in the reverse order to the original VList type: new items are normally added at the <em>beginning</em> of a VList, which is normal in functional languages, but <em>this</em> VList acts like a normal .NET list, so it is optimized for new items to be added at the end. The name "RVList" is ugly, though, since it misleadingly appears to be related to Recreational Vehicles. So as of <a class="el" href="namespaceLeMP.html" title="The lexical macro processor. Main classes: LeMP.Compiler and LeMP.MacroProcessor.">LeMP</a> 1.5, it's called simply VList. </p>
<p>In contrast, the FVList{T} type acts like the original VList; its Add method puts new items at the beginning (index 0). </p>
<p>See the remarks of VListBlock{T} for a more detailed description. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Nested classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4_1_1Enumerator.html">Enumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates through a VList from index 0 up to index Count-1.  <a href="structLoyc_1_1Collections_1_1VList_3_01T_01_4_1_1Enumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:abc7f0c354f5dd93a19544fb2789457c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc7f0c354f5dd93a19544fb2789457c1"></a>
static readonly VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Empty</b> = new VList&lt;T&gt;()</td></tr>
<tr class="separator:abc7f0c354f5dd93a19544fb2789457c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a9c25e96b43013e9eee3ac4cf0b974abf"><td class="memItemLeft" align="right" valign="top">VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a9c25e96b43013e9eee3ac4cf0b974abf">Tail</a><code> [get]</code></td></tr>
<tr class="memdesc:a9c25e96b43013e9eee3ac4cf0b974abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list without the last item. If the list is empty, an empty list is retured. <a href="#a9c25e96b43013e9eee3ac4cf0b974abf">More...</a><br /></td></tr>
<tr class="separator:a9c25e96b43013e9eee3ac4cf0b974abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab429ef27c6d66520883bc8402d8e7653"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#ab429ef27c6d66520883bc8402d8e7653">Last</a><code> [get]</code></td></tr>
<tr class="memdesc:ab429ef27c6d66520883bc8402d8e7653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last item of the list (at index Count-1), which is the head of the list. <a href="#ab429ef27c6d66520883bc8402d8e7653">More...</a><br /></td></tr>
<tr class="separator:ab429ef27c6d66520883bc8402d8e7653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9956cbc7b7e2f3a61a8c79f426c7fd16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9956cbc7b7e2f3a61a8c79f426c7fd16"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsEmpty</b><code> [get]</code></td></tr>
<tr class="separator:a9956cbc7b7e2f3a61a8c79f426c7fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dd2d71b3e33709014c1bf2b27a115c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#ae8dd2d71b3e33709014c1bf2b27a115c">BlockChainLength</a><code> [get]</code></td></tr>
<tr class="memdesc:ae8dd2d71b3e33709014c1bf2b27a115c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of blocks used by this list. <a href="#ae8dd2d71b3e33709014c1bf2b27a115c">More...</a><br /></td></tr>
<tr class="separator:ae8dd2d71b3e33709014c1bf2b27a115c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2509357ad130fd1ff4d68ff29dee0e02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2509357ad130fd1ff4d68ff29dee0e02"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>this[int index]</b><code> [get, set]</code></td></tr>
<tr class="separator:a2509357ad130fd1ff4d68ff29dee0e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55e9bfa5eef58ad18ed164a699a2826"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#ab55e9bfa5eef58ad18ed164a699a2826">this[int index, T defaultValue]</a><code> [get]</code></td></tr>
<tr class="memdesc:ab55e9bfa5eef58ad18ed164a699a2826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an item from the list at the specified index; returns defaultValue if the index is not valid. <a href="#ab55e9bfa5eef58ad18ed164a699a2826">More...</a><br /></td></tr>
<tr class="separator:ab55e9bfa5eef58ad18ed164a699a2826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006234308f4535503c6967b8c5c854f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a006234308f4535503c6967b8c5c854f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Count</b><code> [get]</code></td></tr>
<tr class="separator:a006234308f4535503c6967b8c5c854f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50502d8f75972a9293cd6dbff7161e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac50502d8f75972a9293cd6dbff7161e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsReadOnly</b><code> [get]</code></td></tr>
<tr class="separator:ac50502d8f75972a9293cd6dbff7161e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5693af4d4b3bd0e56ca7c7f32ce1c306"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5693af4d4b3bd0e56ca7c7f32ce1c306"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (T firstItem)</td></tr>
<tr class="separator:a5693af4d4b3bd0e56ca7c7f32ce1c306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6287c4d9f68723fe1956096accf082ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6287c4d9f68723fe1956096accf082ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (T itemZero, T itemOne)</td></tr>
<tr class="separator:a6287c4d9f68723fe1956096accf082ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc48194e27d26b1b5ae4be9eb24449a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bc48194e27d26b1b5ae4be9eb24449a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (T[] array)</td></tr>
<tr class="separator:a8bc48194e27d26b1b5ae4be9eb24449a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af0454542f853c16d4232c0b6c5fe76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1af0454542f853c16d4232c0b6c5fe76"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (IEnumerable&lt; T &gt; list)</td></tr>
<tr class="separator:a1af0454542f853c16d4232c0b6c5fe76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea59126e5d402d669787636120328a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ea59126e5d402d669787636120328a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VList</b> (VList&lt; T &gt; list)</td></tr>
<tr class="separator:a5ea59126e5d402d669787636120328a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0899349e78497c6ddb833ebad4d1bd08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0899349e78497c6ddb833ebad4d1bd08"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WithoutLast</b> (int offset)</td></tr>
<tr class="separator:a0899349e78497c6ddb833ebad4d1bd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96940de9beecfbbcab6623faffbb020"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad96940de9beecfbbcab6623faffbb020"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NextIn</b> (VList&lt; T &gt; largerList)</td></tr>
<tr class="separator:ad96940de9beecfbbcab6623faffbb020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1dedb0ba93cd276ad45a793b5b1e39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f1dedb0ba93cd276ad45a793b5b1e39"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>First</b> (int count)</td></tr>
<tr class="separator:a0f1dedb0ba93cd276ad45a793b5b1e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03b31527812c8eff3e9b2cd8187734b"><td class="memItemLeft" align="right" valign="top">override bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#ab03b31527812c8eff3e9b2cd8187734b">Equals</a> (object rhs_)</td></tr>
<tr class="memdesc:ab03b31527812c8eff3e9b2cd8187734b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two list references are the same. Does not compare the contents of the lists. <a href="#ab03b31527812c8eff3e9b2cd8187734b">More...</a><br /></td></tr>
<tr class="separator:ab03b31527812c8eff3e9b2cd8187734b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3030763f880cb7812641c6f672c0279"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3030763f880cb7812641c6f672c0279"></a>
override int&#160;</td><td class="memItemRight" valign="bottom"><b>GetHashCode</b> ()</td></tr>
<tr class="separator:ab3030763f880cb7812641c6f672c0279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bf480c11b01b35a8e4794aa1be143f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7bf480c11b01b35a8e4794aa1be143f"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (VList&lt; T &gt; list)</td></tr>
<tr class="separator:aa7bf480c11b01b35a8e4794aa1be143f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1e3987e527c215cbb0d00191d79253"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb1e3987e527c215cbb0d00191d79253"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (VList&lt; T &gt; list, VList&lt; T &gt; excludeSubList)</td></tr>
<tr class="separator:afb1e3987e527c215cbb0d00191d79253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84491e016b4280fadb21a6f194451c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae84491e016b4280fadb21a6f194451c7"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (IList&lt; T &gt; list)</td></tr>
<tr class="separator:ae84491e016b4280fadb21a6f194451c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab535df73b58a212cbdd98de0fbbd7d2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab535df73b58a212cbdd98de0fbbd7d2f"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRange</b> (IEnumerable&lt; T &gt; list)</td></tr>
<tr class="separator:ab535df73b58a212cbdd98de0fbbd7d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d36690c919cc215921ab8a26122ff41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d36690c919cc215921ab8a26122ff41"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InsertRange</b> (int index, IList&lt; T &gt; list)</td></tr>
<tr class="separator:a3d36690c919cc215921ab8a26122ff41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5973a0a7f688b8711bcbb1641f1ff96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5973a0a7f688b8711bcbb1641f1ff96"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveRange</b> (int index, int count)</td></tr>
<tr class="separator:ae5973a0a7f688b8711bcbb1641f1ff96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436ad98f6f524870b45ece96733ffcf8"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a436ad98f6f524870b45ece96733ffcf8">Pop</a> ()</td></tr>
<tr class="memdesc:a436ad98f6f524870b45ece96733ffcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last item (at index Count-1) from the list and returns it. <a href="#a436ad98f6f524870b45ece96733ffcf8">More...</a><br /></td></tr>
<tr class="separator:a436ad98f6f524870b45ece96733ffcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb01b7f5cdbb7f1b933fe8a051c19318"><td class="memItemLeft" align="right" valign="top">VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#adb01b7f5cdbb7f1b933fe8a051c19318">Push</a> (T item)</td></tr>
<tr class="memdesc:adb01b7f5cdbb7f1b933fe8a051c19318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a2899333f96298ded3387aab12021b349" title="Inserts an item at the back (index Count) of the VList.">Add()</a>; adds an item to the front of the list. <a href="#adb01b7f5cdbb7f1b933fe8a051c19318">More...</a><br /></td></tr>
<tr class="separator:adb01b7f5cdbb7f1b933fe8a051c19318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dbf9520695ec0b6cf4d90993c668c1"><td class="memItemLeft" align="right" valign="top">FVList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a95dbf9520695ec0b6cf4d90993c668c1">ToFVList</a> ()</td></tr>
<tr class="memdesc:a95dbf9520695ec0b6cf4d90993c668c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a FVList, which effectively reverses the order of the elements. <a href="#a95dbf9520695ec0b6cf4d90993c668c1">More...</a><br /></td></tr>
<tr class="separator:a95dbf9520695ec0b6cf4d90993c668c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4385955fa9d1be7981ddc252d6f8e"><td class="memItemLeft" align="right" valign="top">FWList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a49d4385955fa9d1be7981ddc252d6f8e">ToFWList</a> ()</td></tr>
<tr class="memdesc:a49d4385955fa9d1be7981ddc252d6f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a FWList, which effectively reverses the order of the elements. <a href="#a49d4385955fa9d1be7981ddc252d6f8e">More...</a><br /></td></tr>
<tr class="separator:a49d4385955fa9d1be7981ddc252d6f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66059b968b4840ebd52c7fb53fd6b1e"><td class="memItemLeft" align="right" valign="top">WList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#ad66059b968b4840ebd52c7fb53fd6b1e">ToWList</a> ()</td></tr>
<tr class="memdesc:ad66059b968b4840ebd52c7fb53fd6b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as an WList. <a href="#ad66059b968b4840ebd52c7fb53fd6b1e">More...</a><br /></td></tr>
<tr class="separator:ad66059b968b4840ebd52c7fb53fd6b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1afb6082c7800d527b48570c2b37389"><td class="memItemLeft" align="right" valign="top">T[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#ab1afb6082c7800d527b48570c2b37389">ToArray</a> ()</td></tr>
<tr class="memdesc:ab1afb6082c7800d527b48570c2b37389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the VList converted to an array. <a href="#ab1afb6082c7800d527b48570c2b37389">More...</a><br /></td></tr>
<tr class="separator:ab1afb6082c7800d527b48570c2b37389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c80ebfc94685daacd87c4c483aff72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#ac9c80ebfc94685daacd87c4c483aff72">IndexOf</a> (T item)</td></tr>
<tr class="memdesc:ac9c80ebfc94685daacd87c4c483aff72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the specified object and returns the zero-based index of the first occurrence (lowest index) within the entire VList. <a href="#ac9c80ebfc94685daacd87c4c483aff72">More...</a><br /></td></tr>
<tr class="separator:ac9c80ebfc94685daacd87c4c483aff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4290cc3bc5b8af2cb2a017b60879fa2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4290cc3bc5b8af2cb2a017b60879fa2c"></a>
<a class="el" href="structLoyc_1_1void.html">void</a> IList&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>Insert</b> (int index, T item)</td></tr>
<tr class="separator:a4290cc3bc5b8af2cb2a017b60879fa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d0f5fc125aa70a87a5a51500f77a52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14d0f5fc125aa70a87a5a51500f77a52"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Insert</b> (int index, T item)</td></tr>
<tr class="separator:a14d0f5fc125aa70a87a5a51500f77a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19115167d1db0e6e97887e4b55377def"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19115167d1db0e6e97887e4b55377def"></a>
<a class="el" href="structLoyc_1_1void.html">void</a> IList&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt</b> (int index)</td></tr>
<tr class="separator:a19115167d1db0e6e97887e4b55377def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5414401fdf86784dfb8b43d8cf7e4af1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5414401fdf86784dfb8b43d8cf7e4af1"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveAt</b> (int index)</td></tr>
<tr class="separator:a5414401fdf86784dfb8b43d8cf7e4af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2899333f96298ded3387aab12021b349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLoyc_1_1void.html">void</a> ICollection&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a2899333f96298ded3387aab12021b349">Add</a> (T item)</td></tr>
<tr class="memdesc:a2899333f96298ded3387aab12021b349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item at the back (index Count) of the VList. <a href="#a2899333f96298ded3387aab12021b349">More...</a><br /></td></tr>
<tr class="separator:a2899333f96298ded3387aab12021b349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdd1ee9e7d7ab4ebac20749a046f5f9"><td class="memItemLeft" align="right" valign="top">VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a1fdd1ee9e7d7ab4ebac20749a046f5f9">Add</a> (T item)</td></tr>
<tr class="memdesc:a1fdd1ee9e7d7ab4ebac20749a046f5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item at the back (index Count) of the VList. <a href="#a1fdd1ee9e7d7ab4ebac20749a046f5f9">More...</a><br /></td></tr>
<tr class="separator:a1fdd1ee9e7d7ab4ebac20749a046f5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0676836fa05195947074c6e887fdcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e0676836fa05195947074c6e887fdcf"></a>
<a class="el" href="structLoyc_1_1void.html">void</a> ICollection&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>Clear</b> ()</td></tr>
<tr class="separator:a6e0676836fa05195947074c6e887fdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dc2d69cd93de24d0e548622684578a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56dc2d69cd93de24d0e548622684578a"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Clear</b> ()</td></tr>
<tr class="separator:a56dc2d69cd93de24d0e548622684578a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664b39c0a7a4a4aafb61a0a24e1e45a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a664b39c0a7a4a4aafb61a0a24e1e45a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Contains</b> (T item)</td></tr>
<tr class="separator:a664b39c0a7a4a4aafb61a0a24e1e45a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8364d8d0aa2632224c542d63f1a75ad8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8364d8d0aa2632224c542d63f1a75ad8"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CopyTo</b> (T[] array, int arrayIndex)</td></tr>
<tr class="separator:a8364d8d0aa2632224c542d63f1a75ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6bdb8ef56811f23148a205597402c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c6bdb8ef56811f23148a205597402c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Remove</b> (T item)</td></tr>
<tr class="separator:a2c6bdb8ef56811f23148a205597402c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dfe871f006cd1e207666a48b5a8539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02dfe871f006cd1e207666a48b5a8539"></a>
Enumerator&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a02dfe871f006cd1e207666a48b5a8539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa5901c96c9e13a2ffcca24862c3294"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fa5901c96c9e13a2ffcca24862c3294"></a>
IEnumerator&lt; T &gt; IEnumerable&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a9fa5901c96c9e13a2ffcca24862c3294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2882c1acee7b83d59e53425194038761"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2882c1acee7b83d59e53425194038761"></a>
System.Collections.IEnumerator <br class="typebreak" />
System.Collections.IEnumerable.&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a2882c1acee7b83d59e53425194038761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d397c93e83cadbc2b4a9b63838bff3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a43d397c93e83cadbc2b4a9b63838bff3">TryGet</a> (int index, out bool fail)</td></tr>
<tr class="memdesc:a43d397c93e83cadbc2b4a9b63838bff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the item at the specified index, and does not throw an exception on failure. <a href="#a43d397c93e83cadbc2b4a9b63838bff3">More...</a><br /></td></tr>
<tr class="separator:a43d397c93e83cadbc2b4a9b63838bff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b073e9a68a581e95ef5214558a96eb4"><td class="memItemLeft" align="right" valign="top">IRange&lt; T &gt; IListSource&lt; T &gt;.&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a3b073e9a68a581e95ef5214558a96eb4">Slice</a> (int start, int count)</td></tr>
<tr class="memdesc:a3b073e9a68a581e95ef5214558a96eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub-range of this list. <a href="#a3b073e9a68a581e95ef5214558a96eb4">More...</a><br /></td></tr>
<tr class="separator:a3b073e9a68a581e95ef5214558a96eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f7386cfc2ca334af863b0a4144db35"><td class="memItemLeft" align="right" valign="top">Slice_&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#aa1f7386cfc2ca334af863b0a4144db35">Slice</a> (int start, int count=int.MaxValue)</td></tr>
<tr class="memdesc:aa1f7386cfc2ca334af863b0a4144db35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub-range of this list. <a href="#aa1f7386cfc2ca334af863b0a4144db35">More...</a><br /></td></tr>
<tr class="separator:aa1f7386cfc2ca334af863b0a4144db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f8a9a57799a100c0f92d765b047175"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94f8a9a57799a100c0f92d765b047175"></a>
VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Clone</b> ()</td></tr>
<tr class="separator:a94f8a9a57799a100c0f92d765b047175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3da7a26a9b10f031b9c5f27f34bf3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b3da7a26a9b10f031b9c5f27f34bf3c"></a>
object ICloneable.&#160;</td><td class="memItemRight" valign="bottom"><b>Clone</b> ()</td></tr>
<tr class="separator:a2b3da7a26a9b10f031b9c5f27f34bf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b71ef4a78876f6ae62fadd1b248e7d"><td class="memItemLeft" align="right" valign="top">VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a71b71ef4a78876f6ae62fadd1b248e7d">Where</a> (Predicate&lt; T &gt; keep)</td></tr>
<tr class="memdesc:a71b71ef4a78876f6ae62fadd1b248e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a filter to a list, to exclude zero or more items. <a href="#a71b71ef4a78876f6ae62fadd1b248e7d">More...</a><br /></td></tr>
<tr class="separator:a71b71ef4a78876f6ae62fadd1b248e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3751829c3359ff56319fe6d93b6be40a"><td class="memItemLeft" align="right" valign="top">VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a3751829c3359ff56319fe6d93b6be40a">WhereSelect</a> (Func&lt; T, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt;&gt; filter)</td></tr>
<tr class="memdesc:a3751829c3359ff56319fe6d93b6be40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters and maps a list with a user-defined function. <a href="#a3751829c3359ff56319fe6d93b6be40a">More...</a><br /></td></tr>
<tr class="separator:a3751829c3359ff56319fe6d93b6be40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67946c8c8878afaa9f282b37849a0769"><td class="memItemLeft" align="right" valign="top">VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a67946c8c8878afaa9f282b37849a0769">SmartSelect</a> (Func&lt; T, T &gt; map)</td></tr>
<tr class="memdesc:a67946c8c8878afaa9f282b37849a0769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list to another list of the same length. <a href="#a67946c8c8878afaa9f282b37849a0769">More...</a><br /></td></tr>
<tr class="separator:a67946c8c8878afaa9f282b37849a0769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482f963bb4e2523d205410cf68910072"><td class="memItemLeft" align="right" valign="top">VList&lt; Out &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a482f963bb4e2523d205410cf68910072">Select&lt; Out &gt;</a> (Func&lt; T, Out &gt; map)</td></tr>
<tr class="memdesc:a482f963bb4e2523d205410cf68910072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list to another list of the same length. <a href="#a482f963bb4e2523d205410cf68910072">More...</a><br /></td></tr>
<tr class="separator:a482f963bb4e2523d205410cf68910072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ff56cf4b4c97f4449e1ccb4bfcd1c4"><td class="memItemLeft" align="right" valign="top">VList&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">Transform</a> (VListTransformer&lt; T &gt; x)</td></tr>
<tr class="memdesc:a97ff56cf4b4c97f4449e1ccb4bfcd1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a list (combines filtering with selection and more). <a href="#a97ff56cf4b4c97f4449e1ccb4bfcd1c4">More...</a><br /></td></tr>
<tr class="separator:a97ff56cf4b4c97f4449e1ccb4bfcd1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a629e2c08d382f795462be991062f2709"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a629e2c08d382f795462be991062f2709">operator==</a> (VList&lt; T &gt; lhs, VList&lt; T &gt; rhs)</td></tr>
<tr class="memdesc:a629e2c08d382f795462be991062f2709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two list references are the same. Does not compare the contents of the lists. <a href="#a629e2c08d382f795462be991062f2709">More...</a><br /></td></tr>
<tr class="separator:a629e2c08d382f795462be991062f2709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c3c67c05c68deaf8f9f80243bcd494"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#aa9c3c67c05c68deaf8f9f80243bcd494">operator!=</a> (VList&lt; T &gt; lhs, VList&lt; T &gt; rhs)</td></tr>
<tr class="memdesc:aa9c3c67c05c68deaf8f9f80243bcd494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two list references are different. Does not compare the contents of the lists. <a href="#aa9c3c67c05c68deaf8f9f80243bcd494">More...</a><br /></td></tr>
<tr class="separator:aa9c3c67c05c68deaf8f9f80243bcd494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7bf6afcf7052a323ca885cde5aebc9"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#aae7bf6afcf7052a323ca885cde5aebc9">operator FVList&lt; T &gt;</a> (VList&lt; T &gt; list)</td></tr>
<tr class="memdesc:aae7bf6afcf7052a323ca885cde5aebc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a FVList, which effectively reverses the order of the elements. <a href="#aae7bf6afcf7052a323ca885cde5aebc9">More...</a><br /></td></tr>
<tr class="separator:aae7bf6afcf7052a323ca885cde5aebc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bcc8c1a69531930fa7edbe17c7ca59"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#ad7bcc8c1a69531930fa7edbe17c7ca59">operator FWList&lt; T &gt;</a> (VList&lt; T &gt; list)</td></tr>
<tr class="memdesc:ad7bcc8c1a69531930fa7edbe17c7ca59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as a FWList, which effectively reverses the order of the elements. <a href="#ad7bcc8c1a69531930fa7edbe17c7ca59">More...</a><br /></td></tr>
<tr class="separator:ad7bcc8c1a69531930fa7edbe17c7ca59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5456c2d4ea6fd3409f700d5891b32b97"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a5456c2d4ea6fd3409f700d5891b32b97">operator WList&lt; T &gt;</a> (VList&lt; T &gt; list)</td></tr>
<tr class="memdesc:a5456c2d4ea6fd3409f700d5891b32b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this list as an WList. <a href="#a5456c2d4ea6fd3409f700d5891b32b97">More...</a><br /></td></tr>
<tr class="separator:a5456c2d4ea6fd3409f700d5891b32b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2899333f96298ded3387aab12021b349"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLoyc_1_1void.html">void</a> ICollection&lt;T&gt;. Loyc.Collections.VList&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an item at the back (index Count) of the VList.</p>

<p>References <a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a2899333f96298ded3387aab12021b349">Loyc.Collections.VList&lt; T &gt;.Add()</a>.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a2899333f96298ded3387aab12021b349">Loyc.Collections.VList&lt; T &gt;.Add()</a>.</p>

</div>
</div>
<a class="anchor" id="a1fdd1ee9e7d7ab4ebac20749a046f5f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VList&lt;T&gt; Loyc.Collections.VList&lt; T &gt;.Add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an item at the back (index Count) of the VList.</p>

</div>
</div>
<a class="anchor" id="ab03b31527812c8eff3e9b2cd8187734b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override bool Loyc.Collections.VList&lt; T &gt;.Equals </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>rhs_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two list references are the same. Does not compare the contents of the lists.</p>

</div>
</div>
<a class="anchor" id="ac9c80ebfc94685daacd87c4c483aff72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.VList&lt; T &gt;.IndexOf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the specified object and returns the zero-based index of the first occurrence (lowest index) within the entire VList.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item to locate (can be null if T can be null)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the item, or -1 if it was not found.</dd></dl>
<p>This method determines equality using the default equality comparer EqualityComparer.Default for T, the type of values in the list.</p>
<p>This method performs a linear search, and is typically an O(n) operation, where n is Count. However, because the list is searched upward from index 0 to Count-1, if the list's blocks do not increase in size exponentially (due to the way that the list has been modified in the past), the search can have worse performance; the (unlikely) worst case is O(n^2). FVList(of T).<a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#ac9c80ebfc94685daacd87c4c483aff72" title="Searches for the specified object and returns the zero-based index of the first occurrence (lowest in...">IndexOf()</a> doesn't have this problem. </p>

</div>
</div>
<a class="anchor" id="aae7bf6afcf7052a323ca885cde5aebc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Loyc.Collections.VList&lt; T &gt;.operator FVList&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">VList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a FVList, which effectively reverses the order of the elements.</p>
<p>This is a trivial operation; the FVList shares the same memory.</p>

</div>
</div>
<a class="anchor" id="ad7bcc8c1a69531930fa7edbe17c7ca59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Loyc.Collections.VList&lt; T &gt;.operator FWList&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">VList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a FWList, which effectively reverses the order of the elements.</p>
<p>The list contents are not copied until you modify the FWList.</p>

</div>
</div>
<a class="anchor" id="a5456c2d4ea6fd3409f700d5891b32b97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Loyc.Collections.VList&lt; T &gt;.operator WList&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">VList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as an WList.</p>
<p>The list contents are not copied until you modify the WList.</p>

</div>
</div>
<a class="anchor" id="aa9c3c67c05c68deaf8f9f80243bcd494"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Loyc.Collections.VList&lt; T &gt;.operator!= </td>
          <td>(</td>
          <td class="paramtype">VList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two list references are different. Does not compare the contents of the lists.</p>

</div>
</div>
<a class="anchor" id="a629e2c08d382f795462be991062f2709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Loyc.Collections.VList&lt; T &gt;.operator== </td>
          <td>(</td>
          <td class="paramtype">VList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VList&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two list references are the same. Does not compare the contents of the lists.</p>

</div>
</div>
<a class="anchor" id="a436ad98f6f524870b45ece96733ffcf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Loyc.Collections.VList&lt; T &gt;.Pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last item (at index Count-1) from the list and returns it.</p>

</div>
</div>
<a class="anchor" id="adb01b7f5cdbb7f1b933fe8a051c19318"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VList&lt;T&gt; Loyc.Collections.VList&lt; T &gt;.Push </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonym for <a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a2899333f96298ded3387aab12021b349" title="Inserts an item at the back (index Count) of the VList.">Add()</a>; adds an item to the front of the list.</p>

<p>References <a class="el" href="namespaceLoyc_1_1Collections.html#ab3f241a3b553681db7ce9ce14147e4eeaec211f7c20af43e742bf2570c3cb84f9">Loyc.Collections.Add</a>.</p>

</div>
</div>
<a class="anchor" id="a482f963bb4e2523d205410cf68910072"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VList&lt;Out&gt; Loyc.Collections.VList&lt; T &gt;.Select&lt; Out &gt; </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, Out &gt;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list to another list of the same length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A function that transforms each item in the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after the map function is applied to each item. The original VList structure is not modified.</dd></dl>

</div>
</div>
<a class="anchor" id="a3b073e9a68a581e95ef5214558a96eb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IRange&lt;T&gt; IListSource&lt;T&gt;. Loyc.Collections.VList&lt; T &gt;.Slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sub-range of this list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The new range will start at this index in the current list (this location will be index [0] in the new range).</td></tr>
    <tr><td class="paramname">count</td><td>The desired number of elements in the new range, or int.MaxValue to get all elements until the end of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a sub-range of this range.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The start index was below zero.</td></tr>
  </table>
  </dd>
</dl>
<p>The (start, count) range is allowed to be invalid, as long as start is zero or above. </p><ul>
<li>
If count is below zero, or if start is above the original Count, the Count of the new slice is set to zero. </li>
<li>
if (start + count) is above the original Count, the Count of the new slice is reduced to <code>this.Count - start</code>. Implementation note: do not compute (start + count) because it may overflow. Instead, test whether (count &gt; this.Count - start). </li>
</ul>
<p>Most collections should use the following implementation: </p><pre>
IRange&lt;T&gt; IListSource&lt;T&gt;.<a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a3b073e9a68a581e95ef5214558a96eb4" title="Returns a sub-range of this list.">Slice(int start, int count)</a> { return Slice(start, count); }
public Slice_&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a3b073e9a68a581e95ef5214558a96eb4" title="Returns a sub-range of this list.">Slice(int start, int count)</a> { return new Slice_&lt;T&gt;(this, start, count); }
</pre> 
<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource_3_01out_01T_01_4.html#a49a212d9cf49315abb46c5c276521351">Loyc.Collections.IListSource&lt; out T &gt;</a>.</p>

<p>References <a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a3b073e9a68a581e95ef5214558a96eb4">Loyc.Collections.VList&lt; T &gt;.Slice()</a>.</p>

<p>Referenced by <a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a3b073e9a68a581e95ef5214558a96eb4">Loyc.Collections.VList&lt; T &gt;.Slice()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1f7386cfc2ca334af863b0a4144db35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slice_&lt;T&gt; Loyc.Collections.VList&lt; T &gt;.Slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em> = <code>int.MaxValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sub-range of this list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The new range will start at this index in the current list (this location will be index [0] in the new range).</td></tr>
    <tr><td class="paramname">count</td><td>The desired number of elements in the new range, or int.MaxValue to get all elements until the end of the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a sub-range of this range.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ArgumentException</td><td>The start index was below zero.</td></tr>
  </table>
  </dd>
</dl>
<p>The (start, count) range is allowed to be invalid, as long as start is zero or above. </p><ul>
<li>
If count is below zero, or if start is above the original Count, the Count of the new slice is set to zero. </li>
<li>
if (start + count) is above the original Count, the Count of the new slice is reduced to <code>this.Count - start</code>. Implementation note: do not compute (start + count) because it may overflow. Instead, test whether (count &gt; this.Count - start). </li>
</ul>
<p>Most collections should use the following implementation: </p><pre>
IRange&lt;T&gt; IListSource&lt;T&gt;.<a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a3b073e9a68a581e95ef5214558a96eb4" title="Returns a sub-range of this list.">Slice(int start, int count)</a> { return Slice(start, count); }
public Slice_&lt;T&gt; <a class="el" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a3b073e9a68a581e95ef5214558a96eb4" title="Returns a sub-range of this list.">Slice(int start, int count)</a> { return new Slice_&lt;T&gt;(this, start, count); }
</pre> 
<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource_3_01out_01T_01_4.html#a49a212d9cf49315abb46c5c276521351">Loyc.Collections.IListSource&lt; out T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a67946c8c8878afaa9f282b37849a0769"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VList&lt;T&gt; Loyc.Collections.VList&lt; T &gt;.SmartSelect </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, T &gt;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list to another list of the same length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A function that transforms each item in the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after the map function is applied to each item. The original VList structure is not modified.</dd></dl>
<p>This method is called "Smart" because of what happens if the map doesn't do anything. If the map function returns the first N items unmodified, those N items are typically not copied, but shared between the existing list and the new one. This is useful for functional code that sometimes processes a list without modifying it at all. </p>

</div>
</div>
<a class="anchor" id="ab1afb6082c7800d527b48570c2b37389"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T [] Loyc.Collections.VList&lt; T &gt;.ToArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the VList converted to an array.</p>

</div>
</div>
<a class="anchor" id="a95dbf9520695ec0b6cf4d90993c668c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FVList&lt;T&gt; Loyc.Collections.VList&lt; T &gt;.ToFVList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a FVList, which effectively reverses the order of the elements.</p>
<dl class="section return"><dt>Returns</dt><dd>This is a trivial operation; the FVList shares the same memory.</dd></dl>

</div>
</div>
<a class="anchor" id="a49d4385955fa9d1be7981ddc252d6f8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FWList&lt;T&gt; Loyc.Collections.VList&lt; T &gt;.ToFWList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as a FWList, which effectively reverses the order of the elements.</p>
<p>The list contents are not copied until you modify the FWList.</p>

</div>
</div>
<a class="anchor" id="ad66059b968b4840ebd52c7fb53fd6b1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WList&lt;T&gt; Loyc.Collections.VList&lt; T &gt;.ToWList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this list as an WList.</p>
<p>The list contents are not copied until you modify the WList.</p>

</div>
</div>
<a class="anchor" id="a97ff56cf4b4c97f4449e1ccb4bfcd1c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VList&lt;T&gt; Loyc.Collections.VList&lt; T &gt;.Transform </td>
          <td>(</td>
          <td class="paramtype">VListTransformer&lt; T &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a list (combines filtering with selection and more).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Method to apply to each item in the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list formed from transforming all items in the list</dd></dl>
<p>See the documentation of FVList.Transform() for more information.</p>

</div>
</div>
<a class="anchor" id="a43d397c93e83cadbc2b4a9b63838bff3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Loyc.Collections.VList&lt; T &gt;.TryGet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out bool&#160;</td>
          <td class="paramname"><em>fail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the item at the specified index, and does not throw an exception on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An index in the range 0 to Count-1.</td></tr>
    <tr><td class="paramname">fail</td><td>A flag that is set on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at the specified index, or default(T) if the index is not valid.</dd></dl>
<p>In my original design, the caller could provide a value to return on failure, but this would not allow T to be marked as "out" in C# 4. For the same reason, we cannot have a ref/out T parameter. Instead, the following extension methods are provided: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a43d397c93e83cadbc2b4a9b63838bff3">TryGet</a>(<span class="keywordtype">int</span> index, ref T value);</div>
<div class="line">T <a class="code" href="structLoyc_1_1Collections_1_1VList_3_01T_01_4.html#a43d397c93e83cadbc2b4a9b63838bff3">TryGet</a>(<span class="keywordtype">int</span>, T defaultValue);</div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="interfaceLoyc_1_1Collections_1_1IListSource_3_01out_01T_01_4.html#a8e7cf6ebac5f60e3eefbd1a75bcad672">Loyc.Collections.IListSource&lt; out T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a71b71ef4a78876f6ae62fadd1b248e7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VList&lt;T&gt; Loyc.Collections.VList&lt; T &gt;.Where </td>
          <td>(</td>
          <td class="paramtype">Predicate&lt; T &gt;&#160;</td>
          <td class="paramname"><em>keep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a filter to a list, to exclude zero or more items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keep</td><td>A function that chooses which items to include (exclude items by returning false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after filtering has been applied. The original list structure is not modified.</dd></dl>
<p>If the predicate keeps the first N items it is passed, those N items are typically not copied, but shared between the existing list and the new one. </p>

</div>
</div>
<a class="anchor" id="a3751829c3359ff56319fe6d93b6be40a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VList&lt;T&gt; Loyc.Collections.VList&lt; T &gt;.WhereSelect </td>
          <td>(</td>
          <td class="paramtype">Func&lt; T, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters and maps a list with a user-defined function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>A function that chooses which items to include in a new list, and what to change them to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list after filtering has been applied. The original list structure is not modified.</dd></dl>
<p>This is a smart function. If the filter does not modify the first N items it is passed, those N items are typically not copied, but shared between the existing list and the new one. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="ae8dd2d71b3e33709014c1bf2b27a115c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.Collections.VList&lt; T &gt;.BlockChainLength</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of blocks used by this list.</p>
<p>You might look at this property when optimizing your program, because the runtime of some operations increases as the chain length increases. This property runs in O(BlockChainLength) time. Ideally, BlockChainLength is proportional to log_2(Count), but certain VList usage patterns can produce long chains.</p>

</div>
</div>
<a class="anchor" id="ab429ef27c6d66520883bc8402d8e7653"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Loyc.Collections.VList&lt; T &gt;.Last</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last item of the list (at index Count-1), which is the head of the list.</p>

</div>
</div>
<a class="anchor" id="a9c25e96b43013e9eee3ac4cf0b974abf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VList&lt;T&gt; Loyc.Collections.VList&lt; T &gt;.Tail</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list without the last item. If the list is empty, an empty list is retured.</p>

</div>
</div>
<a class="anchor" id="ab55e9bfa5eef58ad18ed164a699a2826"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Loyc.Collections.VList&lt; T &gt;.this[int index, T defaultValue]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an item from the list at the specified index; returns defaultValue if the index is not valid.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 24 2016 09:22:19 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
