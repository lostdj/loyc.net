<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Enhanced C#: Loyc.Syntax.LNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<h1>Documentation moved to <a href="http://ecsharp.net/doc/code">ecsharp.net</a></h1>
<small>GitHub doesn't support HTTP redirects, so you'll be redirected in 3 seconds.</small>
<br/><br/>
<script>
setTimeout(function() {
	if (window.location.href.indexOf('http://loyc.net') == 0) {
	  window.location.href = 'http://ecsharp.net' + window.location.href.substr('http://loyc.net'.length);
	}
}, 3000);
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1Syntax.html">Syntax</a></li><li class="navelem"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Nested classes</a> &#124;
<a href="#pub-static-attribs">Public static fields</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected fields</a> &#124;
<a href="classLoyc_1_1Syntax_1_1LNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.Syntax.LNode Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>All nodes in a <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> syntax tree share this base class. 
 <a href="classLoyc_1_1Syntax_1_1LNode.html#details">More...</a></p>
<hr/><b>Source file</b>:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Core/Loyc.Syntax/LNodes/LNode.cs'>/Core/Loyc.Syntax/LNodes/LNode.cs</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for Loyc.Syntax.LNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLoyc_1_1Syntax_1_1LNode.png" usemap="#Loyc.Syntax.LNode_map" alt=""/>
  <map id="Loyc.Syntax.LNode_map" name="Loyc.Syntax.LNode_map">
<area href="interfaceLoyc_1_1ICloneable_3_01out_01T_01_4.html" title="Interface for types that can duplicate themselves." alt="Loyc.ICloneable&lt; out T &gt;" shape="rect" coords="0,0,159,24"/>
<area href="interfaceLoyc_1_1IHasLocation.html" title="This interface allows an object to declare its "location". It is used by MessageSink.LocationString, which helps convert the "context" of a message into a string." alt="Loyc.IHasLocation" shape="rect" coords="338,0,497,24"/>
<area href="interfaceLoyc_1_1IHasValue_3_01out_01T_01_4.html" title="Interface for things that have a Value property." alt="Loyc.IHasValue&lt; out T &gt;" shape="rect" coords="507,0,666,24"/>
<area href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y..." alt="Loyc.Syntax.CallNode" shape="rect" coords="169,112,328,136"/>
<area href="classLoyc_1_1Syntax_1_1IdNode.html" title="Base class of all nodes that represent simple identifiers (including special symbols such as #foo)..." alt="Loyc.Syntax.IdNode" shape="rect" coords="338,112,497,136"/>
<area href="classLoyc_1_1Syntax_1_1LiteralNode.html" title="Base class of all nodes that represent literal values such as 123 and "foo"." alt="Loyc.Syntax.LiteralNode" shape="rect" coords="507,112,666,136"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>All nodes in a <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> syntax tree share this base class.</p>
<p><a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> defines only three types of nodes: simple symbols, literals, and calls. </p><ul>
<li>
A <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html" title="Base class of all nodes that represent simple identifiers (including special symbols such as #foo)...">IdNode</a> is a simple identifier, such as a VariableName </li>
<li>
A <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html" title="Base class of all nodes that represent literal values such as 123 and &quot;foo&quot;.">LiteralNode</a> is a literal constant, such as 123 or "hello" </li>
<li>
A <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a> encompasses all other kinds of nodes, such as normal function calls like <code>f(x)</code>, generic specifications like <code>f&lt;x&gt;</code> (represented as <code>#of(f, x)</code>), braced blocks of statements (represented as <code>&lt;tt&gt;{}</code>(stmt1, stmt2, ...)), and so on. Also, parenthesized expressions are represented as a call with one argument and <code>null</code> as the <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a6f61573eaf64e0cf5e44e38085311d74" title="Returns the target of a method call, or null if IsCall is false. The target can be a symbol with no n...">Target</a>. </li>
</ul>
<p>This class provides access to all properties of all three types of nodes, in order to make this class easier to access from plain C#, and to avoid unnecessary downcasting in some cases. </p>
<p><a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> nodes are always immutable, except for the 8-bit <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ad2bf9a6e1588146c029ca74b9514c688" title="Indicates the preferred style to use when printing the node to a text string.">Style</a> property which normally affects printing only. </p>
<h3>Background information</h3>
<p>EC# (enhanced C#) is intended to be the starting point of the <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> (Language of your choice) project, which will be a family of programming languages that will share a common representation for the syntax tree and other compiler-related data structures. </p>
<p>Just as LLVM assembly has emerged as a nearly universal standard intermediate representation for back-ends, <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> nodes are intended to be a universal intermediate representation for syntax trees, and <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> will (eventually) include a generic set of tools for semantic analysis so that it provides a generic representation for front-ends. </p>
<p>EC#, then, will be the first language to use the <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> syntax tree representation, known as the "Loyc tree" for short. Most syntax trees are very strongly typed, with separate data types for, say, variable declarations, binary operators, method calls, method declarations, unary operators, and so forth. <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a>, however, defines only three types of Nodes, and this one class provides access to all the parts of a node. There are several reasons for this design: </p><ul>
<li>
Simplicity. Many compilers have thousands of lines of code dedicated to the AST (abstract syntax tree) data structure itself, because each kind of AST node has its own class. </li>
<li>
Serializability. <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> nodes can always be serialized to a plain text "prefix tree" and deserialized back to objects, even by programs that are not designed to handle the language that the tree represents*. This makes it easy to visualize syntax trees or exchange them between programs. </li>
<li>
Extensibility. <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> nodes can represent any language imaginable, and they are suitable for embedded DSLs (domain-specific languages). Since nodes do not enforce a particular structure, they can be used in different ways than originally envisioned. For example, most languages only have "+" as a binary operator, that is, with two arguments. If <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> had a separate class for each AST, there would probably be a PlusOperator class derived from BinaryOperator, or something, with properties "Left" and "Right". But since there is only one node class, a "+" operator with three arguments is always possible; this is denoted by #+(a, b, c) in EC# source code. </li>
</ul>
<ul>
<li>Currently, the only supported languages for plain-text <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> trees are LES and EC# (either normal EC# or prefix-tree notation). </li>
</ul>
<p><a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> trees are comparable to LISP trees, except that "attributes" and position information are added to the tree, and the concept of a "list" is replaced with the concept of a "call", which I feel is a more intuitive notion in most programming languages that are not LISP. </p>
<p><a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a>'s representation is both an blessing and a curse. The advantage is that <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> nodes can be used for almost any purpose, perhaps even representing data instead of code in some cases. However, there is no guarantee that a given AST follows the structure prescribed by a particular programming language, unless a special validation step is performed after parsing. In this way, <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> trees are similar to XML trees, only simpler. </p>
<p>Another major disadvantage is that it is more difficult to interpret a syntax tree correctly: you have to remember that a method definition has the structure <code>#fn(return_type, name, args, body)</code>, so if "node" is a method definition then <code>node.Args[2]</code> represents the return type, for example. In contrast, most compilers have an AST class called <code>MethodDefinition</code> or something, that provides properties such as Name and ReturnType. Once EC# is developed, however, aliases could help avoid this problem by providing a more friendly veneer over the raw nodes. </p>
<p>For optimization purposes, the node class is a class hierarchy, but most users should only use this class and perhaps the three derived classes <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html" title="Base class of all nodes that represent simple identifiers (including special symbols such as #foo)...">IdNode</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html" title="Base class of all nodes that represent literal values such as 123 and &quot;foo&quot;.">LiteralNode</a> and <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a>. Some users will also find it useful to use <a class="el" href="classLoyc_1_1Syntax_1_1LNodeFactory.html" title="Contains helper methods for creating LNodes. An LNodeFactory holds a reference to the current source ...">LNodeFactory</a> for generating synthetic code snippets (bits of code that never existed in any source file), although you can also use the methods defined here in this class: Id(), Literal(), Call(), InParens(). </p>
<p>Normal <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html" title="All nodes in a Loyc syntax tree share this base class.">LNode</a>s are "persistent" in the comp-sci sense, which means that a subtree can be shared among multiple syntax trees, and nodes do not know their own parents. This allows a single node to exist at multiple locations in a syntax tree. This makes manipulation of trees convenient, as there is no need to "detach" a node from one place, or duplicate it, before it can be inserted in another place. Immutable nodes can be safely re-used within different source files or multiple versions of one source file in an IDE's "intellisense" or "code completion" engine.</p>
<h3>The reimplementation</h3>
<p>This implementation has been redesigned (in Subversion, the last version based on the old design is revision 289.) The core concept is the same as described in my blog at <a href="http://loyc-etc.blogspot.ca/2013/04/the-loyc-tree-and-prefix-notation-in-ec.html">http://loyc-etc.blogspot.ca/2013/04/the-loyc-tree-and-prefix-notation-in-ec.html</a> except that the concept of a "Head" has mostly been eliminated, although you might see it occasionally because it still has a meaning. The "head" of a node refers either to the Name of a symbol, the Value of a literal, or the Target of a call (i.e. the name of the method being called, which could be an arbitrarily complex node). In the original implementation, it was also possible to have a complex head (a head that is itself a node) even when the node was not a call; this situation was used to represent an expression in parenthesis. </p>
<p>This didn't quite feel right, so I changed it. Now, only calls can be complex, and the head of a call (the method being called) is called the Target. </p>
<p>In the new version, there are explicitly three types of nodes: symbols, literals, and calls. There is no longer a Head property, instead there are three separate properties for the three kinds of heads, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a301fe1dbd7fa381ebe2233c265ecfec4" title="Returns the Symbol if IsId. If this node is a call (IsCall) and Target.IsId is true, this property returns Target.Name. In all other cases, the name is GSymbol.Empty. Shall not return null.">Name</a> (a <a class="el" href="classLoyc_1_1Symbol.html" title="Represents a symbol, which is a singleton string that supports fast comparisons and extensible enums...">Symbol</a>), <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ab3ba396bab9bfc416f9d9c9929319431" title="Returns the value of a literal node, or NoValue.Value if this node is not a literal (IsLiteral is fal...">Value</a> (an Object), and <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a6f61573eaf64e0cf5e44e38085311d74" title="Returns the target of a method call, or null if IsCall is false. The target can be a symbol with no n...">Target</a> (an <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html" title="All nodes in a Loyc syntax tree share this base class.">LNode</a>). Only call nodes have a Target, and only literal nodes have a Value (as an optimization, StdTriviaNode breaks this rule; it can only do this because it represents special attributes that are outside the normal syntax tree, such as comments). <a class="el" href="classLoyc_1_1Symbol.html" title="Represents a symbol, which is a singleton string that supports fast comparisons and extensible enums...">Symbol</a> nodes have a Name, but I thought it would be useful for some call nodes to also have a Name, which is defined as the name of the Target if the Target is a symbol (if the Target is not a symbol, the Name must be blank.) </p>
<p>An expression in parenthesis is now represented by a call with a blank name (use IsParenthesizedExpr to detect this case; it is incorrect to test <code><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a301fe1dbd7fa381ebe2233c265ecfec4" title="Returns the Symbol if IsId. If this node is a call (IsCall) and Target.IsId is true, this property returns Target.Name. In all other cases, the name is GSymbol.Empty. Shall not return null.">Name</a> == $``</code> because a call with a non-symbol Target also has a blank name.) </p>
<p>The following differences in implementation have been made: </p><ul>
<li>
"Red" and "green" nodes have basically been eliminated, at least for now. </li>
<li>
Nodes normally do not contain parent references anymore </li>
<li>
Mutable nodes have been eliminated, for now. </li>
<li>
There are now three standard subclasses, <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html" title="Base class of all nodes that represent simple identifiers (including special symbols such as #foo)...">IdNode</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html" title="Base class of all nodes that represent literal values such as 123 and &quot;foo&quot;.">LiteralNode</a> and <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a>, and a node can no longer change between classes after it is created. </li>
<li>
An empty Name is now allowed. A literal now has a blank name (instead of #literal) and a method that calls anything other than a simple symbol will also have a blank Name. Note: The <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a301fe1dbd7fa381ebe2233c265ecfec4" title="Returns the Symbol if IsId. If this node is a call (IsCall) and Target.IsId is true, this property returns Target.Name. In all other cases, the name is GSymbol.Empty. Shall not return null.">Name</a> property will still never return null. </li>
<li>
As mentioned, an expression in parenthesis is represented differently. </li>
</ul>
<p>The problems that motivated a redesign are described at <a href="http://loyc-etc.blogspot.ca/2013/05/redesigning-loyc-tree-code.html">http://loyc-etc.blogspot.ca/2013/05/redesigning-loyc-tree-code.html</a> </p>
<p>One very common use of mutable nodes is building lists of statements, e.g. you might create an empty braced block or an empty loop and then add statements to the body of the block or loop. To do this without mutable nodes, create a mutable WList{LNode} instead and add statements there; once the list is finished, create the braced block or loop afterward. The new design stores arguments and attributes in VList{LNode} objects; you can instantly convert your WList to a VList by calling WListBase{LNode}.ToVList(). </p>
<p>During the redesign I've decided on some small changes to the representation of certain expressions in EC#. </p><ul>
<li>
The '.' operator is now treated more like a normal binary operator; <code>a.b.c</code> is now represented <code>#.(#.(a, b), c)</code> rather than <code>#.(a, b, c)</code> mainly because it's easier that way, and because the second representation doesn't buy anything significant other than a need for special-casing. </li>
<li>
<code>int x = 0</code> will now be represented <code>#var(int, x = 0)</code> rather than <code>#var(int, x(0))</code>. I chose the latter representation initially because it is slightly more convenient, because you can always learn the name of the declared variable by calling <code>var.Args[1].Name</code>. However, I decided that it was more important for the syntax tree to be predictable, with obvious connections between normal and prefix notations. Since I decided that <code>alias X = Y;</code> was to be represented <code>#alias(X = Y, #())</code>, it made sense for the syntax tree of a variable declaration to also resemble its C# syntax. There's another small reason: C++ has both styles <code>Foo x(y)</code> and <code>Foo x = y</code>; if <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> were to ever support C++, it would make sense to use <code>#var(Foo, x(y))</code> and <code>#var(Foo, x = y)</code> for these two cases, and I believe C#'s variable declarations are semantically closer to the latter. (Note: another possibility was #var(int, x) = 0, but I decided this wasn't an improvement, it would just shift the pain around.) </li>
<li>
An constructor argument list is required on <em>all</em> types using the #new operator, e.g. <code>new int[] { x }</code> must have an empty set of arguments on int[], i.e. <code>#new(#of(#[],int)(), x)</code>; this rule makes the different kinds of new expressions easier to interpret by making them consistent with each other. </li>
<li>
A missing syntax element is now represented by an empty symbol instead of the symbol #missing. </li>
<li>
I've decided to adopt the "in-expression" generics syntax from Nemerle as an unambiguous alternative to angle brackets: List.[int] means List&lt;int&gt; and the printer will use this syntax in cases where angle brackets are ambiguous. </li>
<li>
By popular demand, constructors will be written this(...) instead of new(...), since both D and Nemerle use the latter notation. </li>
<li>
The \ and $ characters have been swapped;  now denotes a symbol S, while $S now denotes a substitution. </li>
<li>
The \ and $ characters have been swapped;  now denotes a symbol S, while $S now denotes a substitution. Originally EC# was designed just as an extension of C#, so \ made sense as a substitution operator for string interpolation because it doesn't hurt backward compatibility: "Loaded '\(filename)' successfully". But now that my focus has shifted to multi-language interoperability, $ makes more sense, as it is used for string interpolation in at least five other languages and it makes sense to use the same character for both string substitution and code substitution. </li>
</ul>
<h3>Important properties</h3>
<p>The main properties of a node are </p><ol>
<li>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ae344d28e9355aa0e75fbc582bedf78f5" title="Returns the attribute list for this node.">Attrs</a>: holds the attributes of the node, if any. </li>
<li>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a301fe1dbd7fa381ebe2233c265ecfec4" title="Returns the Symbol if IsId. If this node is a call (IsCall) and Target.IsId is true, this property returns Target.Name. In all other cases, the name is GSymbol.Empty. Shall not return null.">Name</a>: the name of an <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html" title="Base class of all nodes that represent simple identifiers (including special symbols such as #foo)...">IdNode</a>, or the name of the <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html" title="Base class of all nodes that represent simple identifiers (including special symbols such as #foo)...">IdNode</a> that is acting as the <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a6f61573eaf64e0cf5e44e38085311d74" title="Returns the target of a method call, or null if IsCall is false. The target can be a symbol with no n...">Target</a> of a <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a>. </li>
<li>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ab3ba396bab9bfc416f9d9c9929319431" title="Returns the value of a literal node, or NoValue.Value if this node is not a literal (IsLiteral is fal...">Value</a>: the value of a <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html" title="Base class of all nodes that represent literal values such as 123 and &quot;foo&quot;.">LiteralNode</a>. </li>
<li>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a6f61573eaf64e0cf5e44e38085311d74" title="Returns the target of a method call, or null if IsCall is false. The target can be a symbol with no n...">Target</a>: the target of a <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a>. It represents a method, macro, or special identifier that is being called. </li>
<li>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#aef941397a7ad3198591a8f1255444844" title="Returns the argument list of this node. Always empty when IsCall==false.">Args</a>: holds the arguments to a <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a>, if any. Returns an empty list if the node does not have an argument list. </li>
<li>
<a class="el" href="classLoyc_1_1Range.html">Range</a>: indicates the source file that the node came from and location in that source file. </li>
<li>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ad2bf9a6e1588146c029ca74b9514c688" title="Indicates the preferred style to use when printing the node to a text string.">Style</a>: an 8-bit flag value that is used as a hint to the node printer about how the node should be printed. For example, a hex literal like 0x10 has the NodeStyle.Alternate style to distinguish it from decimal literals such as 16. Custom display styles that do not fit in the Style property can be expressed with attributes. </li>
</ol>
<p>The argument and attribute lists cannot be null, since they have type VList{Node} which is a struct. </p>
<p><code><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html" title="All nodes in a Loyc syntax tree share this base class.">LNode</a></code> implements INegListSource{T}, so you can loop through all children of the node like this: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = node.Min; i &amp;lt;= node.Max; i++) {</div>
<div class="line">    LNode child = node[i];</div>
<div class="line">}</div>
</div><!-- fragment --><p> You can also use <code>foreach</code>. The children are numbered like this: </p><ul>
<li>
if i is less than -1, node[i] refers to an attribute. Specifically, node[i] means node.Attrs[i + node.Attrs.Count + 1] in that case. </li>
<li>
node[-1] refers to <code>Target</code> (but throws if there is no target) </li>
<li>
Non-negative values are indexes of Args, e.g. node[i] means node.Args[i]. </li>
</ul>
<p><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html" title="All nodes in a Loyc syntax tree share this base class.">LNode</a> also provides <code>Select(child =&gt; result)</code> and <code>ReplaceRecursive(child =&gt; result)</code> methods which allows you to transform all children (Atrrs, Target and Args). Currently there is no <code>Where(child =&gt; bool)</code> method because it is not possible to remove the <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a6f61573eaf64e0cf5e44e38085311d74" title="Returns the target of a method call, or null if IsCall is false. The target can be a symbol with no n...">Target</a> of an <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html" title="All nodes in a Loyc syntax tree share this base class.">LNode</a> (you can still use standard LINQ Where(), of course, but the result is not an <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html" title="All nodes in a Loyc syntax tree share this base class.">LNode</a>).</p>
<h3>Note</h3>
<p>The argument and attribute lists should never contain null nodes. Any code that puts nulls in <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#aef941397a7ad3198591a8f1255444844" title="Returns the argument list of this node. Always empty when IsCall==false.">Args</a> or <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ae344d28e9355aa0e75fbc582bedf78f5" title="Returns the attribute list for this node.">Attrs</a> is buggy. However, we can't ensure nulls are not placed into VList{T} since it's a general-purpose data type, not specialized for <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html" title="All nodes in a Loyc syntax tree share this base class.">LNode</a>. There is code to ensure nulls are not placed in Args and Attrs (NoNulls), but only in debug builds, since null-checking is fairly expensive. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Nested classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode_1_1DeepComparer.html">DeepComparer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An IEqualityComparer that compares nodes structurally. <a href="classLoyc_1_1Syntax_1_1LNode_1_1DeepComparer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLoyc_1_1Syntax_1_1LNode_1_1PushedPrinter.html">PushedPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned by <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#aec680a7dbb7699e35b109ac15dd9b434" title="Helps you change printers temporarily. Usage in C#: using (LNode.PushPrinter(myPrinter)) { ...">PushPrinter(LNodePrinter)</a>. <a href="structLoyc_1_1Syntax_1_1LNode_1_1PushedPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public static fields</h2></td></tr>
<tr class="memitem:acedf66c24bd7f1d22809ab9deb10c937"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acedf66c24bd7f1d22809ab9deb10c937"></a>
static readonly <a class="el" href="classLoyc_1_1Syntax_1_1EmptySourceFile.html">EmptySourceFile</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SyntheticSource</b> = new <a class="el" href="classLoyc_1_1Syntax_1_1EmptySourceFile.html">EmptySourceFile</a>(&quot;&lt;Synthetic Code&gt;&quot;)</td></tr>
<tr class="separator:acedf66c24bd7f1d22809ab9deb10c937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b2c33e3c0b733dc9664093608338e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4b2c33e3c0b733dc9664093608338e9"></a>
static readonly <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Missing</b> = Id(CodeSymbols.Missing)</td></tr>
<tr class="separator:aa4b2c33e3c0b733dc9664093608338e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9a240b979b6196a2d1fe898886708f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa9a240b979b6196a2d1fe898886708f"></a>
static readonly <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InParensTrivia</b> = Id(CodeSymbols.TriviaInParens)</td></tr>
<tr class="separator:aaa9a240b979b6196a2d1fe898886708f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a211792d5ca6f8214a7483152bae6f650"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a211792d5ca6f8214a7483152bae6f650">Range</a><code> [get]</code></td></tr>
<tr class="memdesc:a211792d5ca6f8214a7483152bae6f650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the location and range in source code of this node. <a href="#a211792d5ca6f8214a7483152bae6f650">More...</a><br /></td></tr>
<tr class="separator:a211792d5ca6f8214a7483152bae6f650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002045914ce7a51f2a2b7323ac671ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a002045914ce7a51f2a2b7323ac671ac0">Source</a><code> [get]</code></td></tr>
<tr class="memdesc:a002045914ce7a51f2a2b7323ac671ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the source file (shortcut for <code><a class="el" href="classLoyc_1_1Range.html">Range</a>.Source</code>). <a href="#a002045914ce7a51f2a2b7323ac671ac0">More...</a><br /></td></tr>
<tr class="separator:a002045914ce7a51f2a2b7323ac671ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bf9a6e1588146c029ca74b9514c688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ad2bf9a6e1588146c029ca74b9514c688">Style</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ad2bf9a6e1588146c029ca74b9514c688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the preferred style to use when printing the node to a text string. <a href="#ad2bf9a6e1588146c029ca74b9514c688">More...</a><br /></td></tr>
<tr class="separator:ad2bf9a6e1588146c029ca74b9514c688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5518f28da8ff5115d698840090b84d5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5518f28da8ff5115d698840090b84d5d"></a>
<a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BaseStyle</b><code> [get, set]</code></td></tr>
<tr class="separator:a5518f28da8ff5115d698840090b84d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae344d28e9355aa0e75fbc582bedf78f5"><td class="memItemLeft" align="right" valign="top">virtual VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ae344d28e9355aa0e75fbc582bedf78f5">Attrs</a><code> [get]</code></td></tr>
<tr class="memdesc:ae344d28e9355aa0e75fbc582bedf78f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the attribute list for this node. <a href="#ae344d28e9355aa0e75fbc582bedf78f5">More...</a><br /></td></tr>
<tr class="separator:ae344d28e9355aa0e75fbc582bedf78f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ed01f8d42d56e9531d79589e72f610"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ad6ed01f8d42d56e9531d79589e72f610">IsFrozen</a><code> [get]</code></td></tr>
<tr class="memdesc:ad6ed01f8d42d56e9531d79589e72f610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node is immutable, and false if any part of it can be edited. Currently, mutable nodes are not implemented. <a href="#ad6ed01f8d42d56e9531d79589e72f610">More...</a><br /></td></tr>
<tr class="separator:ad6ed01f8d42d56e9531d79589e72f610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa09640d17b6dde094e2bb4839eb747"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="namespaceLoyc_1_1Syntax.html#af00c062703b2745a9d2ecbe0b7669212">LNodeKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#adfa09640d17b6dde094e2bb4839eb747">Kind</a><code> [get]</code></td></tr>
<tr class="memdesc:adfa09640d17b6dde094e2bb4839eb747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="namespaceLoyc_1_1Syntax.html#af00c062703b2745a9d2ecbe0b7669212" title="The three kinds of nodes in a Loyc tree">LNodeKind</a>: <a class="el" href="classLoyc_1_1Symbol.html" title="Represents a symbol, which is a singleton string that supports fast comparisons and extensible enums...">Symbol</a>, Literal, or Call. <a href="#adfa09640d17b6dde094e2bb4839eb747">More...</a><br /></td></tr>
<tr class="separator:adfa09640d17b6dde094e2bb4839eb747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad188b12f8f11841baf6b383f31a970c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad188b12f8f11841baf6b383f31a970c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsCall</b><code> [get]</code></td></tr>
<tr class="separator:ad188b12f8f11841baf6b383f31a970c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5e924bae03285888bb88c1e21ca549"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b5e924bae03285888bb88c1e21ca549"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsId</b><code> [get]</code></td></tr>
<tr class="separator:a7b5e924bae03285888bb88c1e21ca549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a57f1e7220583b16ceaf58b71f7074"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85a57f1e7220583b16ceaf58b71f7074"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsLiteral</b><code> [get]</code></td></tr>
<tr class="separator:a85a57f1e7220583b16ceaf58b71f7074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301fe1dbd7fa381ebe2233c265ecfec4"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a301fe1dbd7fa381ebe2233c265ecfec4">Name</a><code> [get]</code></td></tr>
<tr class="memdesc:a301fe1dbd7fa381ebe2233c265ecfec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classLoyc_1_1Symbol.html" title="Represents a symbol, which is a singleton string that supports fast comparisons and extensible enums...">Symbol</a> if IsId. If this node is a call (IsCall) and <code>Target.IsId</code> is true, this property returns <code>Target.Name</code>. In all other cases, the name is GSymbol.Empty. Shall not return null. <a href="#a301fe1dbd7fa381ebe2233c265ecfec4">More...</a><br /></td></tr>
<tr class="separator:a301fe1dbd7fa381ebe2233c265ecfec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e1ab2c87f098ccf59f9a689f644708"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a44e1ab2c87f098ccf59f9a689f644708">HasSpecialName</a><code> [get]</code></td></tr>
<tr class="memdesc:a44e1ab2c87f098ccf59f9a689f644708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a301fe1dbd7fa381ebe2233c265ecfec4" title="Returns the Symbol if IsId. If this node is a call (IsCall) and Target.IsId is true, this property returns Target.Name. In all other cases, the name is GSymbol.Empty. Shall not return null.">Name</a> starts with '#'. <a href="#a44e1ab2c87f098ccf59f9a689f644708">More...</a><br /></td></tr>
<tr class="separator:a44e1ab2c87f098ccf59f9a689f644708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96abf3e3b10605915e64e1701299eccd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96abf3e3b10605915e64e1701299eccd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasValue</b><code> [get]</code></td></tr>
<tr class="separator:a96abf3e3b10605915e64e1701299eccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ba396bab9bfc416f9d9c9929319431"><td class="memItemLeft" align="right" valign="top">abstract object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ab3ba396bab9bfc416f9d9c9929319431">Value</a><code> [get]</code></td></tr>
<tr class="memdesc:ab3ba396bab9bfc416f9d9c9929319431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a literal node, or NoValue.Value if this node is not a literal (IsLiteral is false). <a href="#ab3ba396bab9bfc416f9d9c9929319431">More...</a><br /></td></tr>
<tr class="separator:ab3ba396bab9bfc416f9d9c9929319431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f61573eaf64e0cf5e44e38085311d74"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a6f61573eaf64e0cf5e44e38085311d74">Target</a><code> [get]</code></td></tr>
<tr class="memdesc:a6f61573eaf64e0cf5e44e38085311d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target of a method call, or null if IsCall is false. The target can be a symbol with no name (GSymbol.Empty) to represent a parenthesized expression, if there is one argument. <a href="#a6f61573eaf64e0cf5e44e38085311d74">More...</a><br /></td></tr>
<tr class="separator:a6f61573eaf64e0cf5e44e38085311d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef941397a7ad3198591a8f1255444844"><td class="memItemLeft" align="right" valign="top">abstract VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#aef941397a7ad3198591a8f1255444844">Args</a><code> [get]</code></td></tr>
<tr class="memdesc:aef941397a7ad3198591a8f1255444844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the argument list of this node. Always empty when <code>IsCall==false</code>. <a href="#aef941397a7ad3198591a8f1255444844">More...</a><br /></td></tr>
<tr class="separator:aef941397a7ad3198591a8f1255444844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130548f4529a1da652da4e9cbd851ca8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceLoyc_1_1Syntax.html#a6ba7daec9d30e5569a3cc8b4b50e507e">LNodePrinter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a130548f4529a1da652da4e9cbd851ca8">Printer</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a130548f4529a1da652da4e9cbd851ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the default node printer on the current thread, which controls how nodes are serialized to text by default. <a href="#a130548f4529a1da652da4e9cbd851ca8">More...</a><br /></td></tr>
<tr class="separator:a130548f4529a1da652da4e9cbd851ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b9160daf754be89525f86e7d683c42"><td class="memItemLeft" align="right" valign="top">virtual object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#aa0b9160daf754be89525f86e7d683c42">TriviaValue</a><code> [get]</code></td></tr>
<tr class="memdesc:aa0b9160daf754be89525f86e7d683c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of <code>Args[0].Value</code>, if Args[0] exists; otherwise, returns NoValue.Value. <a href="#aa0b9160daf754be89525f86e7d683c42">More...</a><br /></td></tr>
<tr class="separator:aa0b9160daf754be89525f86e7d683c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d6bb500fe9dcd085ece0e610e57bc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6d6bb500fe9dcd085ece0e610e57bc3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasTokenValue</b><code> [get]</code></td></tr>
<tr class="separator:ae6d6bb500fe9dcd085ece0e610e57bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77f0c372e04f35d4bc2d6ce4555a08a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac77f0c372e04f35d4bc2d6ce4555a08a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ArgCount</b><code> [get]</code></td></tr>
<tr class="separator:ac77f0c372e04f35d4bc2d6ce4555a08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f926ad88a75192c3fc513f4e943e269"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f926ad88a75192c3fc513f4e943e269"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AttrCount</b><code> [get]</code></td></tr>
<tr class="separator:a5f926ad88a75192c3fc513f4e943e269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09f490a36a11593b92ce05730cbccb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af09f490a36a11593b92ce05730cbccb3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasAttrs</b><code> [get]</code></td></tr>
<tr class="separator:af09f490a36a11593b92ce05730cbccb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82afcc16fbbcd87ce950548ba8aaa011"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82afcc16fbbcd87ce950548ba8aaa011"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsTrivia</b><code> [get]</code></td></tr>
<tr class="separator:a82afcc16fbbcd87ce950548ba8aaa011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe96b5246aab0f9dde4e850c9a842aa9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe96b5246aab0f9dde4e850c9a842aa9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Min</b><code> [get]</code></td></tr>
<tr class="separator:afe96b5246aab0f9dde4e850c9a842aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad700239d3412ef1f52e5867a2269819c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad700239d3412ef1f52e5867a2269819c"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>Max</b><code> [get]</code></td></tr>
<tr class="separator:ad700239d3412ef1f52e5867a2269819c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5a887319229c5776bd1b26e2252a88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e5a887319229c5776bd1b26e2252a88"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>this[int index]</b><code> [get]</code></td></tr>
<tr class="separator:a2e5a887319229c5776bd1b26e2252a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfca557baa99ab7bfdeca7936070403"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bfca557baa99ab7bfdeca7936070403"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Count</b><code> [get]</code></td></tr>
<tr class="separator:a0bfca557baa99ab7bfdeca7936070403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interfaceLoyc_1_1IHasLocation"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceLoyc_1_1IHasLocation')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceLoyc_1_1IHasLocation.html">Loyc.IHasLocation</a></td></tr>
<tr class="memitem:a97ffacc6ac52815c15c26212474f150d inherit properties_interfaceLoyc_1_1IHasLocation"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97ffacc6ac52815c15c26212474f150d"></a>
object&#160;</td><td class="memItemRight" valign="bottom"><b>Location</b><code> [get]</code></td></tr>
<tr class="separator:a97ffacc6ac52815c15c26212474f150d inherit properties_interfaceLoyc_1_1IHasLocation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interfaceLoyc_1_1IHasValue_3_01out_01T_01_4"><td colspan="2" onclick="javascript:toggleInherit('properties_interfaceLoyc_1_1IHasValue_3_01out_01T_01_4')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interfaceLoyc_1_1IHasValue_3_01out_01T_01_4.html">Loyc.IHasValue&lt; out T &gt;</a></td></tr>
<tr class="memitem:a3e016da146d3cce3579136b84d9b25bc inherit properties_interfaceLoyc_1_1IHasValue_3_01out_01T_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e016da146d3cce3579136b84d9b25bc"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>Value</b><code> [get]</code></td></tr>
<tr class="separator:a3e016da146d3cce3579136b84d9b25bc inherit properties_interfaceLoyc_1_1IHasValue_3_01out_01T_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13e88e005c9d9ab6b5b93b65384a18e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13e88e005c9d9ab6b5b93b65384a18e1"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SetBaseStyle</b> (<a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> s)</td></tr>
<tr class="separator:a13e88e005c9d9ab6b5b93b65384a18e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeea2d8479ca508318feb1d93a1668bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeea2d8479ca508318feb1d93a1668bc"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SetStyle</b> (<a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> s)</td></tr>
<tr class="separator:aaeea2d8479ca508318feb1d93a1668bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc7c19286f8d82e622127da8b806132"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a0cc7c19286f8d82e622127da8b806132">WithName</a> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name)</td></tr>
<tr class="memdesc:a0cc7c19286f8d82e622127da8b806132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a node with a new value for Name. <a href="#a0cc7c19286f8d82e622127da8b806132">More...</a><br /></td></tr>
<tr class="separator:a0cc7c19286f8d82e622127da8b806132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464391437516b7f58449af6d8a1b6401"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html">LiteralNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a464391437516b7f58449af6d8a1b6401">WithValue</a> (object value)</td></tr>
<tr class="memdesc:a464391437516b7f58449af6d8a1b6401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new literal node with a different Value than the current literal node. <a href="#a464391437516b7f58449af6d8a1b6401">More...</a><br /></td></tr>
<tr class="separator:a464391437516b7f58449af6d8a1b6401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa016fa89aff42c0ad70d08534ddb3e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa016fa89aff42c0ad70d08534ddb3e5"></a>
virtual <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithTarget</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> target)</td></tr>
<tr class="separator:afa016fa89aff42c0ad70d08534ddb3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b61fa44abb6b5c12396756733467b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7b61fa44abb6b5c12396756733467b9"></a>
virtual <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithTarget</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name)</td></tr>
<tr class="separator:ad7b61fa44abb6b5c12396756733467b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406a157154471b738c0ea068a55e6136"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a406a157154471b738c0ea068a55e6136">WithArgs</a> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args)</td></tr>
<tr class="memdesc:a406a157154471b738c0ea068a55e6136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Node with a new argument list. If this node is not a call, a new node is created using this node as its target. Otherwise, the existing argument list is replaced. <a href="#a406a157154471b738c0ea068a55e6136">More...</a><br /></td></tr>
<tr class="separator:a406a157154471b738c0ea068a55e6136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9436665fc3def9e35cf764b44b785c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#afc9436665fc3def9e35cf764b44b785c">With</a> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> target, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args)</td></tr>
<tr class="memdesc:afc9436665fc3def9e35cf764b44b785c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a> with the same attributes and <a class="el" href="classLoyc_1_1Range.html">Range</a>, but a different target and argument list. If the current node is not a <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a>, it becomes one (the <a class="el" href="classLoyc_1_1Range.html">Range</a>, Style and attributes of the current node are kept, but the Kind, Value, and Name are discarded.) <a href="#afc9436665fc3def9e35cf764b44b785c">More...</a><br /></td></tr>
<tr class="separator:afc9436665fc3def9e35cf764b44b785c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e26f0f490a4c97ac59fee241f482aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a70e26f0f490a4c97ac59fee241f482aa">With</a> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> target, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args)</td></tr>
<tr class="memdesc:a70e26f0f490a4c97ac59fee241f482aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a> with the same attributes and <a class="el" href="classLoyc_1_1Range.html">Range</a>, but a different target and argument list. If the current node is not a <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a>, it becomes one (the <a class="el" href="classLoyc_1_1Range.html">Range</a>, Style and attributes of the current node are kept, but the Kind, Value, and Name are discarded.) <a href="#a70e26f0f490a4c97ac59fee241f482aa">More...</a><br /></td></tr>
<tr class="separator:a70e26f0f490a4c97ac59fee241f482aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb946a5deb1e47454c573880883ac16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefb946a5deb1e47454c573880883ac16"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>With</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> target, params <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>[] args)</td></tr>
<tr class="separator:aefb946a5deb1e47454c573880883ac16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa485882d412623cc3199efe2effecaf1"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#aa485882d412623cc3199efe2effecaf1">Clone</a> ()</td></tr>
<tr class="memdesc:aa485882d412623cc3199efe2effecaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the node. Since nodes are immutable, there is little reason for an end-user to call this, but <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#aa485882d412623cc3199efe2effecaf1" title="Creates a copy of the node. Since nodes are immutable, there is little reason for an end-user to call...">Clone()</a> is used internally as a helper method by the WithXyz() methods. <a href="#aa485882d412623cc3199efe2effecaf1">More...</a><br /></td></tr>
<tr class="separator:aa485882d412623cc3199efe2effecaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463a310eef54c7406715c1f52de63755"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a463a310eef54c7406715c1f52de63755"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithRange</b> (<a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range)</td></tr>
<tr class="separator:a463a310eef54c7406715c1f52de63755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8593b8919c8ce8328ba221661dcd5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a8593b8919c8ce8328ba221661dcd5b"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithRange</b> (int startIndex, int endIndex)</td></tr>
<tr class="separator:a9a8593b8919c8ce8328ba221661dcd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc48d5d5147f2d6bae078b1bf5bbde61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc48d5d5147f2d6bae078b1bf5bbde61"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithStyle</b> (<a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style)</td></tr>
<tr class="separator:abc48d5d5147f2d6bae078b1bf5bbde61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90f4a15ab4a6c1cd197c584ddd5aed5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad90f4a15ab4a6c1cd197c584ddd5aed5"></a>
virtual <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>With</b> (<a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style)</td></tr>
<tr class="separator:ad90f4a15ab4a6c1cd197c584ddd5aed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638090c1d7fead9b672340773ecd01b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a638090c1d7fead9b672340773ecd01b8"></a>
virtual <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithoutAttrs</b> ()</td></tr>
<tr class="separator:a638090c1d7fead9b672340773ecd01b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f004b7e4eb15af74cabf1864bfe6f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89f004b7e4eb15af74cabf1864bfe6f0"></a>
abstract <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithAttrs</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs)</td></tr>
<tr class="separator:a89f004b7e4eb15af74cabf1864bfe6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fe749a3d2edc4775bec082e2ec2d9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97fe749a3d2edc4775bec082e2ec2d9e"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithAttrs</b> (params <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>[] attrs)</td></tr>
<tr class="separator:a97fe749a3d2edc4775bec082e2ec2d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dd817272eab59fc81cb680bb38fe52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68dd817272eab59fc81cb680bb38fe52"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithArgs</b> (params <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>[] args)</td></tr>
<tr class="separator:a68dd817272eab59fc81cb680bb38fe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d02fcfd6642ef2736bbdc36302f9b09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d02fcfd6642ef2736bbdc36302f9b09"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PlusAttr</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> attr)</td></tr>
<tr class="separator:a7d02fcfd6642ef2736bbdc36302f9b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217b7b009555033c98cdddc0bb7721db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a217b7b009555033c98cdddc0bb7721db"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PlusAttrs</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs)</td></tr>
<tr class="separator:a217b7b009555033c98cdddc0bb7721db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71695a7dca50a1daf2573749c42c566e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71695a7dca50a1daf2573749c42c566e"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PlusAttrs</b> (IEnumerable&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs)</td></tr>
<tr class="separator:a71695a7dca50a1daf2573749c42c566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e796d5a5eab136877c3993a2bc9dba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1e796d5a5eab136877c3993a2bc9dba"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PlusAttrs</b> (params <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>[] attrs)</td></tr>
<tr class="separator:aa1e796d5a5eab136877c3993a2bc9dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae107470271bf00d78392b5b79433aff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae107470271bf00d78392b5b79433aff"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PlusArg</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> arg)</td></tr>
<tr class="separator:aae107470271bf00d78392b5b79433aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13c6f37c1ae5998529204a446acd8ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae13c6f37c1ae5998529204a446acd8ce"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PlusArgs</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args)</td></tr>
<tr class="separator:ae13c6f37c1ae5998529204a446acd8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b97c2e3725065de78ebd29bf5f2e74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30b97c2e3725065de78ebd29bf5f2e74"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PlusArgs</b> (IEnumerable&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args)</td></tr>
<tr class="separator:a30b97c2e3725065de78ebd29bf5f2e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269728f0f81f0b4da4a5e3cace4fd40d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a269728f0f81f0b4da4a5e3cace4fd40d"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PlusArgs</b> (params <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>[] args)</td></tr>
<tr class="separator:a269728f0f81f0b4da4a5e3cace4fd40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88be0b59ccd61f4471541cc85ba9424b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88be0b59ccd61f4471541cc85ba9424b"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithArgChanged</b> (int index, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> newValue)</td></tr>
<tr class="separator:a88be0b59ccd61f4471541cc85ba9424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744710f371310ec1364217933181919f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a744710f371310ec1364217933181919f"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithAttrChanged</b> (int index, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> newValue)</td></tr>
<tr class="separator:a744710f371310ec1364217933181919f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7078f665cbe530fa52ee2af8f8e7b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d7078f665cbe530fa52ee2af8f8e7b1"></a>
abstract <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNodeVisitor.html">LNodeVisitor</a> visitor)</td></tr>
<tr class="separator:a5d7078f665cbe530fa52ee2af8f8e7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2736a0deb93cacdff60d9c34de153f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a2736a0deb93cacdff60d9c34de153f"></a>
abstract <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="interfaceLoyc_1_1Syntax_1_1ILNodeVisitor.html">ILNodeVisitor</a> visitor)</td></tr>
<tr class="separator:a9a2736a0deb93cacdff60d9c34de153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6288055b1982ec02cf87e62220028e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6288055b1982ec02cf87e62220028e8"></a>
virtual string&#160;</td><td class="memItemRight" valign="bottom"><b>Print</b> (object mode=null, string indentString=&quot;\t&quot;, string lineSeparator=&quot;\n&quot;)</td></tr>
<tr class="separator:ad6288055b1982ec02cf87e62220028e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b67eef3f619f74dcb1dad964276a44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04b67eef3f619f74dcb1dad964276a44"></a>
override string&#160;</td><td class="memItemRight" valign="bottom"><b>ToString</b> ()</td></tr>
<tr class="separator:a04b67eef3f619f74dcb1dad964276a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2b5e15d6e0b6e25e52d833f36c32eb"><td class="memItemLeft" align="right" valign="top">abstract bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a8e2b5e15d6e0b6e25e52d833f36c32eb">Equals</a> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> other, bool compareStyles)</td></tr>
<tr class="memdesc:a8e2b5e15d6e0b6e25e52d833f36c32eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two nodes for structural equality. Two green nodes are considered equal if they have the same name, the same value, the same arguments, and the same attributes. IsCall must be the same, but they need not have the same values of SourceWidth or IsFrozen. <a href="#a8e2b5e15d6e0b6e25e52d833f36c32eb">More...</a><br /></td></tr>
<tr class="separator:a8e2b5e15d6e0b6e25e52d833f36c32eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8474bb4eb33df18acc3346deab18c7aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8474bb4eb33df18acc3346deab18c7aa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Equals</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> other)</td></tr>
<tr class="separator:a8474bb4eb33df18acc3346deab18c7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0933e912c6108837110686a96b22a6b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0933e912c6108837110686a96b22a6b5"></a>
override bool&#160;</td><td class="memItemRight" valign="bottom"><b>Equals</b> (object other)</td></tr>
<tr class="separator:a0933e912c6108837110686a96b22a6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e141047050da26c09fd06649ad368c"><td class="memItemLeft" align="right" valign="top">override int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a14e141047050da26c09fd06649ad368c">GetHashCode</a> ()</td></tr>
<tr class="memdesc:a14e141047050da26c09fd06649ad368c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the hash code based on the structure of the tree. <a href="#a14e141047050da26c09fd06649ad368c">More...</a><br /></td></tr>
<tr class="separator:a14e141047050da26c09fd06649ad368c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eed7098b0b4edf582d24daa038ec9f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9eed7098b0b4edf582d24daa038ec9f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasPAttrs</b> ()</td></tr>
<tr class="separator:a9eed7098b0b4edf582d24daa038ec9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711058841a984342c0163e721deedea2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a711058841a984342c0163e721deedea2"></a>
VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PAttrs</b> ()</td></tr>
<tr class="separator:a711058841a984342c0163e721deedea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ba76d2600b73aca2aa8f04fe17bfc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48ba76d2600b73aca2aa8f04fe17bfc6"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>Calls</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, int argCount)</td></tr>
<tr class="separator:a48ba76d2600b73aca2aa8f04fe17bfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346f7e1f265262261551bb4dfd36a3cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a346f7e1f265262261551bb4dfd36a3cd"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>Calls</b> (string name, int argCount)</td></tr>
<tr class="separator:a346f7e1f265262261551bb4dfd36a3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6218083cfe349667e0dfbc45785f4c7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6218083cfe349667e0dfbc45785f4c7d"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>Calls</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name)</td></tr>
<tr class="separator:a6218083cfe349667e0dfbc45785f4c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cff8a418f30ecad07265da32b1e5011"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cff8a418f30ecad07265da32b1e5011"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>Calls</b> (string name)</td></tr>
<tr class="separator:a5cff8a418f30ecad07265da32b1e5011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf78a11db105660bfa6fd6ba3625dc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcf78a11db105660bfa6fd6ba3625dc2"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>CallsMin</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, int argCount)</td></tr>
<tr class="separator:abcf78a11db105660bfa6fd6ba3625dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6864de502e176884337a17e6f95faf9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6864de502e176884337a17e6f95faf9b"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>CallsMin</b> (string name, int argCount)</td></tr>
<tr class="separator:a6864de502e176884337a17e6f95faf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaffe6461fb891bfaed8f5c4aab40716"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#abaffe6461fb891bfaed8f5c4aab40716">HasSimpleHead</a> ()</td></tr>
<tr class="memdesc:abaffe6461fb891bfaed8f5c4aab40716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is not a call, or if the call's Target is an Id or a Literal. <a href="#abaffe6461fb891bfaed8f5c4aab40716">More...</a><br /></td></tr>
<tr class="separator:abaffe6461fb891bfaed8f5c4aab40716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5b4a0a72fb8cf469bf55afeb6d64e5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a4b5b4a0a72fb8cf469bf55afeb6d64e5">HasSimpleHeadWithoutPAttrs</a> ()</td></tr>
<tr class="memdesc:a4b5b4a0a72fb8cf469bf55afeb6d64e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is not a call, or if the call's Target is an Id or a Literal, and the Target has only trivia attributes. <a href="#a4b5b4a0a72fb8cf469bf55afeb6d64e5">More...</a><br /></td></tr>
<tr class="separator:a4b5b4a0a72fb8cf469bf55afeb6d64e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf090777711ce93e64005cf57f96f01b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf090777711ce93e64005cf57f96f01b"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithAttrs</b> (Func&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&gt; selector)</td></tr>
<tr class="separator:abf090777711ce93e64005cf57f96f01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75861b5d59d57ed11d9cb4f9afe4101"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa75861b5d59d57ed11d9cb4f9afe4101"></a>
virtual <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithArgs</b> (Func&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>, <a class="el" href="classLoyc_1_1Maybe.html">Maybe</a>&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&gt; selector)</td></tr>
<tr class="separator:aa75861b5d59d57ed11d9cb4f9afe4101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4618163a86ff0ba59de93df9c043a59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4618163a86ff0ba59de93df9c043a59"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIdWithoutPAttrs</b> ()</td></tr>
<tr class="separator:ab4618163a86ff0ba59de93df9c043a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aca7c80b6a6e37a34a0308865129814"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aca7c80b6a6e37a34a0308865129814"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIdWithoutPAttrs</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name)</td></tr>
<tr class="separator:a3aca7c80b6a6e37a34a0308865129814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1cc349ca191f60c4bc8af82cf05366"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e1cc349ca191f60c4bc8af82cf05366"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIdNamed</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name)</td></tr>
<tr class="separator:a6e1cc349ca191f60c4bc8af82cf05366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbf259c8e012ec0ddd2990fffb2af24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdbf259c8e012ec0ddd2990fffb2af24"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsIdNamed</b> (string name)</td></tr>
<tr class="separator:abdbf259c8e012ec0ddd2990fffb2af24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d8d042eb801b07a16970bd954d5934"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56d8d042eb801b07a16970bd954d5934"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsParenthesizedExpr</b> ()</td></tr>
<tr class="separator:a56d8d042eb801b07a16970bd954d5934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6069132cd52cd9bb9f63105386ffc41a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6069132cd52cd9bb9f63105386ffc41a"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithSplicedArgs</b> (int index, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> from, <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> listName)</td></tr>
<tr class="separator:a6069132cd52cd9bb9f63105386ffc41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a875139e2c4ec143fe671d3d5573b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41a875139e2c4ec143fe671d3d5573b0"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithSplicedArgs</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> from, <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> listName)</td></tr>
<tr class="separator:a41a875139e2c4ec143fe671d3d5573b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2dd6dbd4ac7000054ee9984e5755e7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2dd6dbd4ac7000054ee9984e5755e7e"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithSplicedAttrs</b> (int index, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> from, <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> listName)</td></tr>
<tr class="separator:aa2dd6dbd4ac7000054ee9984e5755e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7a5af74e04439cc63392d9c7fffc80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad7a5af74e04439cc63392d9c7fffc80"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WithSplicedAttrs</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> from, <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> listName)</td></tr>
<tr class="separator:aad7a5af74e04439cc63392d9c7fffc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8709e980c3293cad55b372cc8424704"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8709e980c3293cad55b372cc8424704"></a>
NestedEnumerable<br class="typebreak" />
&lt; <a class="el" href="structLoyc_1_1Syntax_1_1DescendantsFrame.html">DescendantsFrame</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Descendants</b> (<a class="el" href="namespaceLoyc_1_1Syntax.html#ad4c4676e2fe5b3a9acf9f5b02f88b9c1">NodeScanMode</a> mode=NodeScanMode.YieldAllChildren)</td></tr>
<tr class="separator:ae8709e980c3293cad55b372cc8424704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf293f7aa8dd86ecc3b8167770327c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacdf293f7aa8dd86ecc3b8167770327c"></a>
NestedEnumerable<br class="typebreak" />
&lt; <a class="el" href="structLoyc_1_1Syntax_1_1DescendantsFrame.html">DescendantsFrame</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DescendantsAndSelf</b> ()</td></tr>
<tr class="separator:aacdf293f7aa8dd86ecc3b8167770327c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4d4e2c822e2f7b00982dec50f40aab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b4d4e2c822e2f7b00982dec50f40aab"></a>
<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TryGet</b> (int index, out bool fail)</td></tr>
<tr class="separator:a2b4d4e2c822e2f7b00982dec50f40aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce0884ef1b5758ce453f9a776dc3350"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acce0884ef1b5758ce453f9a776dc3350"></a>
IRange&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Slice</b> (int start, int count=int.MaxValue)</td></tr>
<tr class="separator:acce0884ef1b5758ce453f9a776dc3350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121c56ed8da7b378583fa3c284ff92d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a121c56ed8da7b378583fa3c284ff92d6"></a>
IEnumerator&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetEnumerator</b> ()</td></tr>
<tr class="separator:a121c56ed8da7b378583fa3c284ff92d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e1be6d75a8893c913552f0f4deb0d8"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a47e1be6d75a8893c913552f0f4deb0d8">Select</a> (Func&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; selector)</td></tr>
<tr class="memdesc:a47e1be6d75a8893c913552f0f4deb0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the attributes, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a6f61573eaf64e0cf5e44e38085311d74" title="Returns the target of a method call, or null if IsCall is false. The target can be a symbol with no n...">Target</a>, and parameters of an <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html" title="All nodes in a Loyc syntax tree share this base class.">LNode</a>, returning another <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html" title="All nodes in a Loyc syntax tree share this base class.">LNode</a> of the same Kind. If the selector makes no changes, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a47e1be6d75a8893c913552f0f4deb0d8" title="Transforms the attributes, Target, and parameters of an LNode, returning another LNode of the same Ki...">Select()</a> returns <code>this</code>. <a href="#a47e1be6d75a8893c913552f0f4deb0d8">More...</a><br /></td></tr>
<tr class="separator:a47e1be6d75a8893c913552f0f4deb0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200e6751ae8d9214f4b20a423bf4f5fb"><td class="memItemLeft" align="right" valign="top">abstract <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a200e6751ae8d9214f4b20a423bf4f5fb">ReplaceRecursive</a> (Func&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; selector, bool replaceRoot=true)</td></tr>
<tr class="memdesc:a200e6751ae8d9214f4b20a423bf4f5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a recursive find-and-replace operation, by attempting to replace each child (among <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ae344d28e9355aa0e75fbc582bedf78f5" title="Returns the attribute list for this node.">Attrs</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a6f61573eaf64e0cf5e44e38085311d74" title="Returns the target of a method call, or null if IsCall is false. The target can be a symbol with no n...">Target</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#aef941397a7ad3198591a8f1255444844" title="Returns the argument list of this node. Always empty when IsCall==false.">Args</a>) using the specified selector. This method can also be used for simple searching, by giving a selector that always returns null. <a href="#a200e6751ae8d9214f4b20a423bf4f5fb">More...</a><br /></td></tr>
<tr class="separator:a200e6751ae8d9214f4b20a423bf4f5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1a520dc077b411a92ef95accfcde9d08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a520dc077b411a92ef95accfcde9d08"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Id</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:a1a520dc077b411a92ef95accfcde9d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1e7f5afbf8af2e1b3b043a7a3f0336"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf1e7f5afbf8af2e1b3b043a7a3f0336"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Id</b> (string name, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:aaf1e7f5afbf8af2e1b3b043a7a3f0336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7e6beadab6f73873ec8a0f5ffcb238"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad7e6beadab6f73873ec8a0f5ffcb238"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Id</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:aad7e6beadab6f73873ec8a0f5ffcb238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734b746ecd33d66fcb7ba7f7b3981a8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a734b746ecd33d66fcb7ba7f7b3981a8a"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Id</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, string name, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:a734b746ecd33d66fcb7ba7f7b3981a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c47f374738f460e0eb91cec43dc1b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87c47f374738f460e0eb91cec43dc1b3"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html">LiteralNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Literal</b> (object value, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:a87c47f374738f460e0eb91cec43dc1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd86302429100b01eae63b62307ae99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefd86302429100b01eae63b62307ae99"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html">LiteralNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Literal</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, object value, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:aefd86302429100b01eae63b62307ae99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae929acabeb9b34087aad2a8b56d36ca2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae929acabeb9b34087aad2a8b56d36ca2"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:ae929acabeb9b34087aad2a8b56d36ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a11b7c3abc9249230af75bc4962ca13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a11b7c3abc9249230af75bc4962ca13"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> target, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:a1a11b7c3abc9249230af75bc4962ca13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff5c8e86328efc8984a755904801460"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ff5c8e86328efc8984a755904801460"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:a5ff5c8e86328efc8984a755904801460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b83b1ec03ea52d63ff734dd739cfbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31b83b1ec03ea52d63ff734dd739cfbf"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> target, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:a31b83b1ec03ea52d63ff734dd739cfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c845a769b0bf9886c5b1a50d5ec6446"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c845a769b0bf9886c5b1a50d5ec6446"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:a6c845a769b0bf9886c5b1a50d5ec6446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0231cb21d9f43a8d892aa7247e418d0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0231cb21d9f43a8d892aa7247e418d0f"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> target, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:a0231cb21d9f43a8d892aa7247e418d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac8fd8bc1578f4d20fab6be8004ddb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ac8fd8bc1578f4d20fab6be8004ddb1"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Trivia</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, object value, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:a7ac8fd8bc1578f4d20fab6be8004ddb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade43741b076b275771424b2bc18fd4a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade43741b076b275771424b2bc18fd4a4"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InParens</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> node)</td></tr>
<tr class="separator:ade43741b076b275771424b2bc18fd4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bf342e05ee9a433d4487e7648214b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8bf342e05ee9a433d4487e7648214b3"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Id</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:ab8bf342e05ee9a433d4487e7648214b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0451ccca04f152e63f299e3b2bc77932"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0451ccca04f152e63f299e3b2bc77932"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Id</b> (string name, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a0451ccca04f152e63f299e3b2bc77932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d04d30f58d47802f26e784f0a9d6918"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d04d30f58d47802f26e784f0a9d6918"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Id</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a7d04d30f58d47802f26e784f0a9d6918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db29db6b3d6ca7b93dc5c0df80c9b9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5db29db6b3d6ca7b93dc5c0df80c9b9b"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Id</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, string name, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a5db29db6b3d6ca7b93dc5c0df80c9b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491f2cc40e056ec07c3257612f18b746"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a491f2cc40e056ec07c3257612f18b746"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html">LiteralNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Literal</b> (object value, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a491f2cc40e056ec07c3257612f18b746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e96f8f2ce260b65d122e33ee602c5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99e96f8f2ce260b65d122e33ee602c5e"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html">LiteralNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Literal</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, object value, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a99e96f8f2ce260b65d122e33ee602c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4b9f6d0d465890f8afcb1f8e55b332"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f4b9f6d0d465890f8afcb1f8e55b332"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a6f4b9f6d0d465890f8afcb1f8e55b332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69dcb596aa4a113bc9ffbeafe4faa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e69dcb596aa4a113bc9ffbeafe4faa3"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> target, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a7e69dcb596aa4a113bc9ffbeafe4faa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f1e5529ef81177becfcfdc3a51408b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27f1e5529ef81177becfcfdc3a51408b"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a27f1e5529ef81177becfcfdc3a51408b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc4eedb6545d71765254d838ee47adb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cc4eedb6545d71765254d838ee47adb"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> target, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a4cc4eedb6545d71765254d838ee47adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2c7069849e299d6ea022d9e2366380"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f2c7069849e299d6ea022d9e2366380"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a9f2c7069849e299d6ea022d9e2366380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ec15793870dcf2519d045e3cfc64e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4ec15793870dcf2519d045e3cfc64e2"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> target, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:ab4ec15793870dcf2519d045e3cfc64e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee9e4af4414bcbbb16d98119b653aee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ee9e4af4414bcbbb16d98119b653aee"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Trivia</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, object value, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a6ee9e4af4414bcbbb16d98119b653aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313f5f9833fd8d14b64caade7167348c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a313f5f9833fd8d14b64caade7167348c"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InParens</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> node, <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range)</td></tr>
<tr class="separator:a313f5f9833fd8d14b64caade7167348c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09048a8d049509f5f920ef376d558b8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09048a8d049509f5f920ef376d558b8b"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Id</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1)</td></tr>
<tr class="separator:a09048a8d049509f5f920ef376d558b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e728be77ee3722c05c3003ce7c6365"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36e728be77ee3722c05c3003ce7c6365"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Id</b> (string name, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1)</td></tr>
<tr class="separator:a36e728be77ee3722c05c3003ce7c6365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547d2ca8230a831eddf86f89322066a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a547d2ca8230a831eddf86f89322066a6"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Id</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1)</td></tr>
<tr class="separator:a547d2ca8230a831eddf86f89322066a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78485f7a01c80391bfe3b012e003d70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac78485f7a01c80391bfe3b012e003d70"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html">IdNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Id</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, string name, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1)</td></tr>
<tr class="separator:ac78485f7a01c80391bfe3b012e003d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6017ba98bd66fc012c36bf7c8d5b72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f6017ba98bd66fc012c36bf7c8d5b72"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html">LiteralNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Literal</b> (object value, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a6f6017ba98bd66fc012c36bf7c8d5b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343421147a4c513cd37c4f209c7acafe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a343421147a4c513cd37c4f209c7acafe"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html">LiteralNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Literal</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, object value, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a343421147a4c513cd37c4f209c7acafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cc03db5efab59330a5f323f012a3eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05cc03db5efab59330a5f323f012a3eb"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a05cc03db5efab59330a5f323f012a3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195269dc8bc410e3384f2674bfad26e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a195269dc8bc410e3384f2674bfad26e0"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> target, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a195269dc8bc410e3384f2674bfad26e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4f2792b501f3364285ca77fef33dfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add4f2792b501f3364285ca77fef33dfa"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:add4f2792b501f3364285ca77fef33dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2651c080c5e6109f8fb6b388d6edf871"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2651c080c5e6109f8fb6b388d6edf871"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> target, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:a2651c080c5e6109f8fb6b388d6edf871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c5145b11f2f8ec1932badfbf68e38e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8c5145b11f2f8ec1932badfbf68e38e"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:aa8c5145b11f2f8ec1932badfbf68e38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe69a7e5769efca8095afbba609cbf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affe69a7e5769efca8095afbba609cbf3"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Call</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; attrs, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> target, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; args, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:affe69a7e5769efca8095afbba609cbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b15a152ec75b0e7654b04b955786f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8b15a152ec75b0e7654b04b955786f1"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Trivia</b> (<a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> name, object value, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style=NodeStyle.Default)</td></tr>
<tr class="separator:aa8b15a152ec75b0e7654b04b955786f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a045ab48f949ce046bcffc142f4510"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5a045ab48f949ce046bcffc142f4510"></a>
static <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InParens</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> node, <a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> file=null, int position=-1, int width=-1)</td></tr>
<tr class="separator:af5a045ab48f949ce046bcffc142f4510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26a0ec013dd0f4a987375272532fda3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac26a0ec013dd0f4a987375272532fda3"></a>
static VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>List</b> ()</td></tr>
<tr class="separator:ac26a0ec013dd0f4a987375272532fda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902520addb173d3deb35a56513a92558"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a902520addb173d3deb35a56513a92558"></a>
static VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>List</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> list_0)</td></tr>
<tr class="separator:a902520addb173d3deb35a56513a92558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf71fafbfd5d19878c4f6356a451d6cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf71fafbfd5d19878c4f6356a451d6cf"></a>
static VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>List</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> list_0, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> list_1)</td></tr>
<tr class="separator:aaf71fafbfd5d19878c4f6356a451d6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229fc7eb3319ed867bccfe6fd71609a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a229fc7eb3319ed867bccfe6fd71609a1"></a>
static VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>List</b> (params <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>[] list)</td></tr>
<tr class="separator:a229fc7eb3319ed867bccfe6fd71609a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e406817e6f843782f523a5f2c213e56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e406817e6f843782f523a5f2c213e56"></a>
static VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>List</b> (IEnumerable&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; list)</td></tr>
<tr class="separator:a9e406817e6f843782f523a5f2c213e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8378bece4ac6b245b5712b090b4e9bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8378bece4ac6b245b5712b090b4e9bc"></a>
static VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>List</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; list)</td></tr>
<tr class="separator:aa8378bece4ac6b245b5712b090b4e9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec680a7dbb7699e35b109ac15dd9b434"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structLoyc_1_1Syntax_1_1LNode_1_1PushedPrinter.html">PushedPrinter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#aec680a7dbb7699e35b109ac15dd9b434">PushPrinter</a> (<a class="el" href="namespaceLoyc_1_1Syntax.html#a6ba7daec9d30e5569a3cc8b4b50e507e">LNodePrinter</a> printer)</td></tr>
<tr class="memdesc:aec680a7dbb7699e35b109ac15dd9b434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps you change printers temporarily. Usage in C#: <code>using (LNode.PushPrinter(myPrinter)) { ... }</code> <a href="#aec680a7dbb7699e35b109ac15dd9b434">More...</a><br /></td></tr>
<tr class="separator:aec680a7dbb7699e35b109ac15dd9b434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7b6705a30f3c495032695cf4524558"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade7b6705a30f3c495032695cf4524558"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ade7b6705a30f3c495032695cf4524558">Equals</a> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> a, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> b, bool compareStyles=false)</td></tr>
<tr class="separator:ade7b6705a30f3c495032695cf4524558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6a7f1abe7b71318de17bdecb402517"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#abf6a7f1abe7b71318de17bdecb402517">Equals</a> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; a, VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; b, bool compareStyles=false)</td></tr>
<tr class="memdesc:abf6a7f1abe7b71318de17bdecb402517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two lists of nodes for structural equality. <a href="#abf6a7f1abe7b71318de17bdecb402517">More...</a><br /></td></tr>
<tr class="separator:abf6a7f1abe7b71318de17bdecb402517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de98272cbbebd9bd71bdf12cfe1841a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a3de98272cbbebd9bd71bdf12cfe1841a">MergeLists</a> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> node1, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> node2, <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> listName)</td></tr>
<tr class="memdesc:a3de98272cbbebd9bd71bdf12cfe1841a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a>s are used to represent lists. This method merges two nodes, forming or appending a list (see remarks). <a href="#a3de98272cbbebd9bd71bdf12cfe1841a">More...</a><br /></td></tr>
<tr class="separator:a3de98272cbbebd9bd71bdf12cfe1841a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ae66080c5f1937e836a47c79abee02"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#af5ae66080c5f1937e836a47c79abee02">MergeBinary</a> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> node1, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> node2, <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> binaryOpName)</td></tr>
<tr class="memdesc:af5ae66080c5f1937e836a47c79abee02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two nodes using a binary operator or function. <a href="#af5ae66080c5f1937e836a47c79abee02">More...</a><br /></td></tr>
<tr class="separator:af5ae66080c5f1937e836a47c79abee02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac8d881df024a733e7344a61db4faa1e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8d881df024a733e7344a61db4faa1e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LNode</b> (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> prototype)</td></tr>
<tr class="separator:ac8d881df024a733e7344a61db4faa1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2101832662df6eb47c490491c5e3f4be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2101832662df6eb47c490491c5e3f4be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LNode</b> (<a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> range, <a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> style)</td></tr>
<tr class="separator:a2101832662df6eb47c490491c5e3f4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:abf4b38422f9926b33b7d1a70113f5c05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf4b38422f9926b33b7d1a70113f5c05"></a>
static <a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NoNulls</b> (VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt; list, string propName)</td></tr>
<tr class="separator:abf4b38422f9926b33b7d1a70113f5c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected fields</h2></td></tr>
<tr class="memitem:a6e5771fa4b8aebdcb0f185f1e6dadb94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e5771fa4b8aebdcb0f185f1e6dadb94"></a>
RangeAndStyle&#160;</td><td class="memItemRight" valign="bottom"><b>RAS</b></td></tr>
<tr class="separator:a6e5771fa4b8aebdcb0f185f1e6dadb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa485882d412623cc3199efe2effecaf1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> Loyc.Syntax.LNode.Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the node. Since nodes are immutable, there is little reason for an end-user to call this, but <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#aa485882d412623cc3199efe2effecaf1" title="Creates a copy of the node. Since nodes are immutable, there is little reason for an end-user to call...">Clone()</a> is used internally as a helper method by the WithXyz() methods.</p>

<p>Implements <a class="el" href="interfaceLoyc_1_1ICloneable_3_01out_01T_01_4.html">Loyc.ICloneable&lt; out T &gt;</a>.</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#a747c014c8d2e909e7112b02af8355891">Loyc.Syntax.CallNode</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html#a705b13cbb580ee32d7f678d8cb70ccca">Loyc.Syntax.LiteralNode</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html#a49512cc0cc3ff41250beb597846ee199">Loyc.Syntax.IdNode</a>.</p>

</div>
</div>
<a class="anchor" id="abf6a7f1abe7b71318de17bdecb402517"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Loyc.Syntax.LNode.Equals </td>
          <td>(</td>
          <td class="paramtype">VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compareStyles</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two lists of nodes for structural equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareStyles</td><td>Whether to compare values of <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ad2bf9a6e1588146c029ca74b9514c688" title="Indicates the preferred style to use when printing the node to a text string.">Style</a></td></tr>
  </table>
  </dd>
</dl>
<p>Position information is not compared.</p>

</div>
</div>
<a class="anchor" id="a8e2b5e15d6e0b6e25e52d833f36c32eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract bool Loyc.Syntax.LNode.Equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compareStyles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two nodes for structural equality. Two green nodes are considered equal if they have the same name, the same value, the same arguments, and the same attributes. IsCall must be the same, but they need not have the same values of SourceWidth or IsFrozen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareStyles</td><td>Whether to compare values of <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ad2bf9a6e1588146c029ca74b9514c688" title="Indicates the preferred style to use when printing the node to a text string.">Style</a></td></tr>
  </table>
  </dd>
</dl>
<p>Position information (<a class="el" href="classLoyc_1_1Range.html">Range</a>) is not compared.</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#ab9b1c60dc97d9864f2abc5af634ab3ce">Loyc.Syntax.CallNode</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html#aebe455efe4ffe7a3269d4b7b69b04757">Loyc.Syntax.LiteralNode</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html#a186f669ce2e92f6b641679bd06cf9030">Loyc.Syntax.IdNode</a>.</p>

</div>
</div>
<a class="anchor" id="a14e141047050da26c09fd06649ad368c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override int Loyc.Syntax.LNode.GetHashCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the hash code based on the structure of the tree.</p>
<p>If the tree is large, less than the entire tree is scanned to produce the hashcode (in the absolute worst case, about 4000 nodes are examined, but usually it is less than 100). </p>

<p>References <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a14e141047050da26c09fd06649ad368c">Loyc.Syntax.LNode.GetHashCode()</a>.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a14e141047050da26c09fd06649ad368c">Loyc.Syntax.LNode.GetHashCode()</a>.</p>

</div>
</div>
<a class="anchor" id="abaffe6461fb891bfaed8f5c4aab40716"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Loyc.Syntax.LNode.HasSimpleHead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is not a call, or if the call's Target is an Id or a Literal.</p>

<p>Reimplemented in <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#ad5beb8ea5874807c4c0eae765f3b31ad">Loyc.Syntax.CallNode</a>.</p>

</div>
</div>
<a class="anchor" id="a4b5b4a0a72fb8cf469bf55afeb6d64e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Loyc.Syntax.LNode.HasSimpleHeadWithoutPAttrs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is not a call, or if the call's Target is an Id or a Literal, and the Target has only trivia attributes.</p>

<p>Reimplemented in <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#acda83c0c4d8f443aedd6c256357dd1d3">Loyc.Syntax.CallNode</a>.</p>

</div>
</div>
<a class="anchor" id="af5ae66080c5f1937e836a47c79abee02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> Loyc.Syntax.LNode.MergeBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td>
          <td class="paramname"><em>node2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Symbol.html">Symbol</a>&#160;</td>
          <td class="paramname"><em>binaryOpName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines two nodes using a binary operator or function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>First node, list, or null.</td></tr>
    <tr><td class="paramname">node2</td><td>Second node, list, or null.</td></tr>
    <tr><td class="paramname">binaryOpName</td><td>Binary operator to use when the nodes are not null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If either node1 or node2 is null, this method returns the other node (node1 ?? node2), otherwise the nodes are joined with the specified operator.</dd></dl>

</div>
</div>
<a class="anchor" id="a3de98272cbbebd9bd71bdf12cfe1841a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> Loyc.Syntax.LNode.MergeLists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td>
          <td class="paramname"><em>node2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Symbol.html">Symbol</a>&#160;</td>
          <td class="paramname"><em>listName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a>s are used to represent lists. This method merges two nodes, forming or appending a list (see remarks).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>First node, list, or null.</td></tr>
    <tr><td class="paramname">node2</td><td>Second node, list, or null.</td></tr>
    <tr><td class="paramname">listName</td><td>The <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a301fe1dbd7fa381ebe2233c265ecfec4" title="Returns the Symbol if IsId. If this node is a call (IsCall) and Target.IsId is true, this property returns Target.Name. In all other cases, the name is GSymbol.Empty. Shall not return null.">Name</a> used to detect whether a node is a list (typically "#splice"). Any other name is considered a normal call, not a list. If this method creates a list from two non- lists, this parameter specifies the Name that the list will have.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The merged list.</dd></dl>
<p>The order of the data is retained (i.e. the data in node1 is inserted before the data in node2). </p><ul>
<li>
If either node1 or node2 is null, this method returns the other (node1 ?? node2). </li>
<li>
If both node1 and node2 are lists, this method merges the list into a single list by appending node2's arguments at the end of node1. The attributes of node1 are kept and those of node2 are discarded. </li>
<li>
If one of the nodes is a list and the other is not, the non-list is inserted into the list's Args. </li>
<li>
If neither node is a list, a list is created with both nodes as its two Args. </li>
</ul>
<dl class="section see"><dt>See also</dt><dd>LNodeExt.WithSpliced</dd></dl>

</div>
</div>
<a class="anchor" id="aec680a7dbb7699e35b109ac15dd9b434"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structLoyc_1_1Syntax_1_1LNode_1_1PushedPrinter.html">PushedPrinter</a> Loyc.Syntax.LNode.PushPrinter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceLoyc_1_1Syntax.html#a6ba7daec9d30e5569a3cc8b4b50e507e">LNodePrinter</a>&#160;</td>
          <td class="paramname"><em>printer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helps you change printers temporarily. Usage in C#: <code>using (LNode.PushPrinter(myPrinter)) { ... }</code></p>
<p>For example, to switch to the EC# printer, use <code>using (<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#aec680a7dbb7699e35b109ac15dd9b434" title="Helps you change printers temporarily. Usage in C#: using (LNode.PushPrinter(myPrinter)) { ...">LNode.PushPrinter</a>(EcsNodePrinter.Printer)) { ... }</code>. This changes the default printer. If you don't want to change the default printer, please invoke the printer directly: </p><div class="fragment"><div class="line">var sb = <span class="keyword">new</span> StringBuilder();</div>
<div class="line">EcsNodePrinter.Printer(node, sb, <a class="code" href="classLoyc_1_1MessageSink.html#a4f256aef66590eabe6d541a3c3506b67">MessageSink.Trace</a>);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a200e6751ae8d9214f4b20a423bf4f5fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> Loyc.Syntax.LNode.ReplaceRecursive </td>
          <td>(</td>
          <td class="paramtype">Func&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceRoot</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a recursive find-and-replace operation, by attempting to replace each child (among <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#ae344d28e9355aa0e75fbc582bedf78f5" title="Returns the attribute list for this node.">Attrs</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a6f61573eaf64e0cf5e44e38085311d74" title="Returns the target of a method call, or null if IsCall is false. The target can be a symbol with no n...">Target</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#aef941397a7ad3198591a8f1255444844" title="Returns the argument list of this node. Always empty when IsCall==false.">Args</a>) using the specified selector. This method can also be used for simple searching, by giving a selector that always returns null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The selector is called for each descendant, and optionally the root node. If the selector returns a node, the new node replaces the node that was passed to <code>selector</code> and the children of the new node are ignored. If the selector returns null, children of the child are scanned recursively.</td></tr>
    <tr><td class="paramname">replaceRoot</td><td>Whether to call <code>selector(this)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new node produced after all replacements have occurred.</dd></dl>
<p>If <code>replaceFunc</code> always returns null (or if <code>replaceRoot</code> is false and the root has no children), <code>ReplaceRecursive</code> returns <code>this</code>.</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#a8ad5cf1f21e5f01bb556d3ec23fa8381">Loyc.Syntax.CallNode</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html#a6e5096b5969ff9f0ca36ca30e47b9aaa">Loyc.Syntax.LiteralNode</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html#a3eb431894b1360783a71d4d7ea8fb457">Loyc.Syntax.IdNode</a>.</p>

</div>
</div>
<a class="anchor" id="a47e1be6d75a8893c913552f0f4deb0d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> Loyc.Syntax.LNode.Select </td>
          <td>(</td>
          <td class="paramtype">Func&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the attributes, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a6f61573eaf64e0cf5e44e38085311d74" title="Returns the target of a method call, or null if IsCall is false. The target can be a symbol with no n...">Target</a>, and parameters of an <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html" title="All nodes in a Loyc syntax tree share this base class.">LNode</a>, returning another <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html" title="All nodes in a Loyc syntax tree share this base class.">LNode</a> of the same Kind. If the selector makes no changes, <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a47e1be6d75a8893c913552f0f4deb0d8" title="Transforms the attributes, Target, and parameters of an LNode, returning another LNode of the same Ki...">Select()</a> returns <code>this</code>.</p>
<p>The selector is not allowed to return null.</p>

<p>Implemented in <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#a352deaac38864bb5ad96a2908fc08f91">Loyc.Syntax.CallNode</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html#a9c73e51cd2ab5edebd75979a8c0f1206">Loyc.Syntax.LiteralNode</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html#ad4c7d431fb2d175f2426e8bf2eb2a651">Loyc.Syntax.IdNode</a>.</p>

</div>
</div>
<a class="anchor" id="afc9436665fc3def9e35cf764b44b785c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a> Loyc.Syntax.LNode.With </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a> with the same attributes and <a class="el" href="classLoyc_1_1Range.html">Range</a>, but a different target and argument list. If the current node is not a <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a>, it becomes one (the <a class="el" href="classLoyc_1_1Range.html">Range</a>, Style and attributes of the current node are kept, but the Kind, Value, and Name are discarded.)</p>

</div>
</div>
<a class="anchor" id="a70e26f0f490a4c97ac59fee241f482aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a> Loyc.Syntax.LNode.With </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Symbol.html">Symbol</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a> with the same attributes and <a class="el" href="classLoyc_1_1Range.html">Range</a>, but a different target and argument list. If the current node is not a <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html" title="Base class of all nodes that represent calls such as f(x), operator calls such as x + y...">CallNode</a>, it becomes one (the <a class="el" href="classLoyc_1_1Range.html">Range</a>, Style and attributes of the current node are kept, but the Kind, Value, and Name are discarded.)</p>

</div>
</div>
<a class="anchor" id="a406a157154471b738c0ea068a55e6136"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html">CallNode</a> Loyc.Syntax.LNode.WithArgs </td>
          <td>(</td>
          <td class="paramtype">VList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Node with a new argument list. If this node is not a call, a new node is created using this node as its target. Otherwise, the existing argument list is replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>New argument list</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#aa26db505e1da43420ef7e840c9fa3a36">Loyc.Syntax.CallNode</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html#aea99c2d89d0744711e876c3164c48743">Loyc.Syntax.LiteralNode</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html#ad67fc2f0a2367fc16aa14247ac8bb7b1">Loyc.Syntax.IdNode</a>.</p>

</div>
</div>
<a class="anchor" id="a0cc7c19286f8d82e622127da8b806132"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> Loyc.Syntax.LNode.WithName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLoyc_1_1Symbol.html">Symbol</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a node with a new value for Name.</p>
<p>If IsId, the Name is simply changed. If IsCall, this method returns the equivalent of <code>WithTarget(Target.WithName(name))</code> (which may be optimized for the particular call type). If IsLiteral, the <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#adfa09640d17b6dde094e2bb4839eb747" title="Returns the LNodeKind: Symbol, Literal, or Call.">Kind</a> changes to LNodeKind.Id in order to set the name.</p>

<p>Reimplemented in <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#a34dca504f6046c6a176dbd48408f11fb">Loyc.Syntax.CallNode</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html#a3523b1247156856770a7091f5b9be806">Loyc.Syntax.IdNode</a>.</p>

</div>
</div>
<a class="anchor" id="a464391437516b7f58449af6d8a1b6401"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html">LiteralNode</a> Loyc.Syntax.LNode.WithValue </td>
          <td>(</td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new literal node with a different Value than the current literal node.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The node was not a literal already.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#a63d96bdc28d37b7e96def9ea4f4efba0">Loyc.Syntax.CallNode</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html#a764e6197e823e4228aeff3cc2573195c">Loyc.Syntax.LiteralNode</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html#abde47184569fc1100610d45bc1ebb217">Loyc.Syntax.IdNode</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="aef941397a7ad3198591a8f1255444844"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract VList&lt;<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&gt; Loyc.Syntax.LNode.Args</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the argument list of this node. Always empty when <code>IsCall==false</code>.</p>
<p>Depending on the <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a6f61573eaf64e0cf5e44e38085311d74" title="Returns the target of a method call, or null if IsCall is false. The target can be a symbol with no n...">Target</a>, Args may represent an actual argument list, or it may represent some other kind of list. For example, if the target is "{}" then Args represents a list of statements in a braced block, and if the target is "&gt;=" then Args represents the two arguments to the "&gt;=" operator. </p>

<p>Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1LNodeExt.html#a7d993d054a056f5333452551e7c0385f">Loyc.Syntax.LNodeExt.AsList()</a>, <a class="el" href="classLoyc_1_1LLParserGenerator_1_1CodeGenHelperBase.html#ad21004a27b781f5380d402ad0e2cad40">Loyc.LLParserGenerator.CodeGenHelperBase.CallRule()</a>, <a class="el" href="classLoyc_1_1LLParserGenerator_1_1IntStreamCodeGenHelper.html#a4563a4b17e51fc94ffbf89de2116bfcf">Loyc.LLParserGenerator.IntStreamCodeGenHelper.CodeToTerminalPred()</a>, <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#ab9b1c60dc97d9864f2abc5af634ab3ce">Loyc.Syntax.CallNode.Equals()</a>, <a class="el" href="classLoyc_1_1Ecs_1_1EcsValidators.html#a26006ff95c953dff4e4e9768eb5c5863">Loyc.Ecs.EcsValidators.KeyNameComponentOf()</a>, <a class="el" href="classLoyc_1_1LLPG_1_1Macros.html#ae102955f76c97cf0f27303b6d616e43d">Loyc.LLPG.Macros.LLLPG_parser()</a>, <a class="el" href="classLoyc_1_1LLParserGenerator_1_1CodeGenHelperBase.html#a88aa254b7cf196c03245564ac51fc004">Loyc.LLParserGenerator.CodeGenHelperBase.SetListInitializer()</a>, and <a class="el" href="classLoyc_1_1Ecs_1_1EcsValidators.html#a1844f801e52ca0f5840327014ec6bc0f">Loyc.Ecs.EcsValidators.SpaceStatementKind()</a>.</p>

</div>
</div>
<a class="anchor" id="ae344d28e9355aa0e75fbc582bedf78f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual VList&lt;<a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&gt; Loyc.Syntax.LNode.Attrs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the attribute list for this node.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html#a186f669ce2e92f6b641679bd06cf9030">Loyc.Syntax.IdNode.Equals()</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html#aebe455efe4ffe7a3269d4b7b69b04757">Loyc.Syntax.LiteralNode.Equals()</a>, <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#ab9b1c60dc97d9864f2abc5af634ab3ce">Loyc.Syntax.CallNode.Equals()</a>, and <a class="el" href="classLoyc_1_1Ecs_1_1EcsValidators.html#af9674f0329d85ca378bc1326e03e1ab0">Loyc.Ecs.EcsValidators.IsPrintableTypeParam()</a>.</p>

</div>
</div>
<a class="anchor" id="a44e1ab2c87f098ccf59f9a689f644708"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.Syntax.LNode.HasSpecialName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a301fe1dbd7fa381ebe2233c265ecfec4" title="Returns the Symbol if IsId. If this node is a call (IsCall) and Target.IsId is true, this property returns Target.Name. In all other cases, the name is GSymbol.Empty. Shall not return null.">Name</a> starts with '#'.</p>
<p>Note that this property returns false for the empty identifier <code>@``</code>.</p>

</div>
</div>
<a class="anchor" id="ad6ed01f8d42d56e9531d79589e72f610"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Loyc.Syntax.LNode.IsFrozen</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the node is immutable, and false if any part of it can be edited. Currently, mutable nodes are not implemented.</p>
<p>Debugger-hidden until such time as mutable nodes actually exist.</p>

</div>
</div>
<a class="anchor" id="adfa09640d17b6dde094e2bb4839eb747"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="namespaceLoyc_1_1Syntax.html#af00c062703b2745a9d2ecbe0b7669212">LNodeKind</a> Loyc.Syntax.LNode.Kind</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="namespaceLoyc_1_1Syntax.html#af00c062703b2745a9d2ecbe0b7669212" title="The three kinds of nodes in a Loyc tree">LNodeKind</a>: <a class="el" href="classLoyc_1_1Symbol.html" title="Represents a symbol, which is a singleton string that supports fast comparisons and extensible enums...">Symbol</a>, Literal, or Call.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html#a186f669ce2e92f6b641679bd06cf9030">Loyc.Syntax.IdNode.Equals()</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html#aebe455efe4ffe7a3269d4b7b69b04757">Loyc.Syntax.LiteralNode.Equals()</a>, <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#ab9b1c60dc97d9864f2abc5af634ab3ce">Loyc.Syntax.CallNode.Equals()</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1LNodeExt.html#ad20bab0fd1ed507bf5fce0650168d303">Loyc.Syntax.LNodeExt.MatchesPattern()</a>.</p>

</div>
</div>
<a class="anchor" id="a301fe1dbd7fa381ebe2233c265ecfec4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a> Loyc.Syntax.LNode.Name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classLoyc_1_1Symbol.html" title="Represents a symbol, which is a singleton string that supports fast comparisons and extensible enums...">Symbol</a> if IsId. If this node is a call (IsCall) and <code>Target.IsId</code> is true, this property returns <code>Target.Name</code>. In all other cases, the name is GSymbol.Empty. Shall not return null.</p>
<p>Examples (using C#/LES syntax): </p><pre>
Expression   Kind    Name (blank if empty)
hello        Id      hello
#if         Id      #if
Foo(x, y)    Call    Foo
x += y       Call    +=
x.Foo(y)     Call    
5.0          Literal 
</pre> 
<p>Referenced by <a class="el" href="classLoyc_1_1LLParserGenerator_1_1GeneralCodeGenHelper.html#a5edd51343c6c103948fab211ac8128dd">Loyc.LLParserGenerator.GeneralCodeGenHelper.CodeToTerminalPred()</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1LNodeExt.html#ad20bab0fd1ed507bf5fce0650168d303">Loyc.Syntax.LNodeExt.MatchesPattern()</a>.</p>

</div>
</div>
<a class="anchor" id="a130548f4529a1da652da4e9cbd851ca8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceLoyc_1_1Syntax.html#a6ba7daec9d30e5569a3cc8b4b50e507e">LNodePrinter</a> Loyc.Syntax.LNode.Printer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the default node printer on the current thread, which controls how nodes are serialized to text by default.</p>
<p>The LES printer is the default, and will be used if you try to set this property to null.</p>

</div>
</div>
<a class="anchor" id="a211792d5ca6f8214a7483152bae6f650"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structLoyc_1_1Syntax_1_1SourceRange.html">SourceRange</a> Loyc.Syntax.LNode.Range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the location and range in source code of this node.</p>
<p>A parser should record a sufficiently wide range for each parent node, such that all children are fully contained within the range. However, this is not an invariant; macros can splice together syntax trees from different source files or add synthetic nodes, so that the parent range does not necessarily include all child ranges. (In fact, in general it is impossible to ensure that parent ranges include child ranges because a parent can only specify a single source file, while children can come from several source files.) </p>

</div>
</div>
<a class="anchor" id="a002045914ce7a51f2a2b7323ac671ac0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> Loyc.Syntax.LNode.Source</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the source file (shortcut for <code><a class="el" href="classLoyc_1_1Range.html">Range</a>.Source</code>).</p>

</div>
</div>
<a class="anchor" id="ad2bf9a6e1588146c029ca74b9514c688"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceLoyc_1_1Syntax.html#abc3eedb6b204244ecdfdfeacb1d433b8">NodeStyle</a> Loyc.Syntax.LNode.Style</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the preferred style to use when printing the node to a text string.</p>
<p>The Style is an 8-bit value that acts as a hint to the node printer about how the node should be printed. Custom display styles that do not fit in the Style property can be expressed with special attributes that have a <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html#a301fe1dbd7fa381ebe2233c265ecfec4" title="Returns the Symbol if IsId. If this node is a call (IsCall) and Target.IsId is true, this property returns Target.Name. In all other cases, the name is GSymbol.Empty. Shall not return null.">Name</a> starting with "#trivia_". ("#trivia" attributes, which are also used to store comments in the syntax tree, are not printed like normal attributes and are normally ignored if the node printer does not specifically recognize them.) </p>

<p>Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1IdNode.html#a186f669ce2e92f6b641679bd06cf9030">Loyc.Syntax.IdNode.Equals()</a>, <a class="el" href="classLoyc_1_1Syntax_1_1LiteralNode.html#aebe455efe4ffe7a3269d4b7b69b04757">Loyc.Syntax.LiteralNode.Equals()</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#ab9b1c60dc97d9864f2abc5af634ab3ce">Loyc.Syntax.CallNode.Equals()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f61573eaf64e0cf5e44e38085311d74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> Loyc.Syntax.LNode.Target</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the target of a method call, or null if IsCall is false. The target can be a symbol with no name (GSymbol.Empty) to represent a parenthesized expression, if there is one argument.</p>

<p>Referenced by <a class="el" href="classLoyc_1_1Syntax_1_1CallNode.html#ab9b1c60dc97d9864f2abc5af634ab3ce">Loyc.Syntax.CallNode.Equals()</a>, <a class="el" href="classLoyc_1_1Ecs_1_1EcsValidators.html#a26006ff95c953dff4e4e9768eb5c5863">Loyc.Ecs.EcsValidators.KeyNameComponentOf()</a>, and <a class="el" href="classLoyc_1_1Syntax_1_1LNodeExt.html#ad20bab0fd1ed507bf5fce0650168d303">Loyc.Syntax.LNodeExt.MatchesPattern()</a>.</p>

</div>
</div>
<a class="anchor" id="aa0b9160daf754be89525f86e7d683c42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual object Loyc.Syntax.LNode.TriviaValue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value of <code>Args[0].Value</code>, if Args[0] exists; otherwise, returns NoValue.Value.</p>
<p>"Trivia nodes" are used to efficiently represent the value of trivia and non-tree <a class="el" href="structLoyc_1_1Syntax_1_1Lexing_1_1Token.html" title="A common token type recommended for Loyc languages that want to use features such as token literals o...">Lexing.Token</a>s; they can be created by calling the LNode.Trivia function. Since an <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html" title="All nodes in a Loyc syntax tree share this base class.">LNode</a> is not allowed to have both a Name and a Value (as there is no syntax in LES or EC# for such a node), a trivia node pretends that there is an argument list with one item, and that one item is always a literal whose Value is the value stored in the trivia node. Thus, a token node is printed out as <code>TokenType(Value)</code> where <code>Value</code> is some literal. </p>
<p>If you suspect you're dealing with a trivia node, it is wasteful to actually call <code>node.Args[0].Value</code> since this causes a temporary token list to be allocated. Instead you should use this property, which returns the token value without allocating memory. Of course, if this property is called on a non-trivia node, it simply returns <code>Args[0].Value</code>. </p>

</div>
</div>
<a class="anchor" id="ab3ba396bab9bfc416f9d9c9929319431"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract object Loyc.Syntax.LNode.Value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of a literal node, or NoValue.Value if this node is not a literal (IsLiteral is false).</p>

<p>Referenced by <a class="el" href="classLoyc_1_1LLParserGenerator_1_1IntStreamCodeGenHelper.html#a4563a4b17e51fc94ffbf89de2116bfcf">Loyc.LLParserGenerator.IntStreamCodeGenHelper.CodeToTerminalPred()</a>, and <a class="el" href="classLoyc_1_1LLPG_1_1Macros.html#ae102955f76c97cf0f27303b6d616e43d">Loyc.LLPG.Macros.LLLPG_parser()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 24 2016 09:22:26 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
