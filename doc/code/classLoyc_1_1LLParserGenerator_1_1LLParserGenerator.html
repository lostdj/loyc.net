<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Enhanced C#: Loyc.LLParserGenerator.LLParserGenerator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Enhanced C#
   </div>
   <div id="projectbrief">Language of your choice: library documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<h1>Documentation moved to <a href="http://ecsharp.net/doc/code">ecsharp.net</a></h1>
<small>GitHub doesn't support HTTP redirects, so you'll be redirected in 3 seconds.</small>
<br/><br/>
<script>
setTimeout(function() {
	if (window.location.href.indexOf('http://loyc.net') == 0) {
	  window.location.href = 'http://ecsharp.net' + window.location.href.substr('http://loyc.net'.length);
	}
}, 3000);
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLoyc.html">Loyc</a></li><li class="navelem"><a class="el" href="namespaceLoyc_1_1LLParserGenerator.html">LLParserGenerator</a></li><li class="navelem"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html">LLParserGenerator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Nested classes</a> &#124;
<a href="#pub-attribs">Public fields</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected fields</a> &#124;
<a href="#pro-static-attribs">Protected static fields</a> &#124;
<a href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Loyc.LLParserGenerator.LLParserGenerator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates LLLPG, the <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> LL Parser Generator, which generates LL(k) recursive-descent parsers. 
 <a href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html#details">More...</a></p>
<hr/><b>Source file</b>s:<ul>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Main/LLLPG/CoreEngine/AnalysisVisitors.cs'>/Main/LLLPG/CoreEngine/AnalysisVisitors.cs</a></li>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Main/LLLPG/CoreEngine/LLParserGenerator.cs'>/Main/LLLPG/CoreEngine/LLParserGenerator.cs</a></li>
<li><a href='https://github.com/qwertie/ecsharp/tree/master/Main/LLLPG/CoreEngine/PredictionTree.cs'>/Main/LLLPG/CoreEngine/PredictionTree.cs</a></li>
</ul>
<a name="details" id="details"></a><h2 class="groupheader">Remarks</h2>
<div class="textblock"><p>Encapsulates LLLPG, the <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> LL Parser Generator, which generates LL(k) recursive-descent parsers.</p>
<p>LLLPG is a new LL(k) parser generator under the umbrella of the <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> project (<a href="http://loyc.net">http://loyc.net</a>). </p>
<p>LLLPG generates recursive-descent parsers for LL(k) grammars. It is designed for parsing computer languages, not natural languages. It also it supports "syntactic predicates" which are zero-width syntactic assertions, and "semantic predicates" which are arbitrary expressions. </p>
<p>The <a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html" title="Encapsulates LLLPG, the Loyc LL Parser Generator, which generates LL(k) recursive-descent parsers...">LLParserGenerator</a> class is the core engine. It generates parsers in the form of a <a class="el" href="namespaceLoyc.html" title="Main Loyc namespace. This namespace includes all general-purpose code in the Loyc megaproject...">Loyc</a> tree, which can be printed out as C# code. Look at the documentation of the <a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html#a2287db28b2b9044187ab4c62207bcd12" title="Generates a braced block of code {...} for the grammar described by the rules that were previously ad...">Run()</a> method for an overview of how the LLLPG engine works. </p>
<p>Note: the input to LLLPG is usually provided in the form of LES/EC# source code. In that case, there is no need to use this class directly. The source code of Program.Main shows how to invoke LLLPG as a macro via the <a class="el" href="classLeMP_1_1Compiler.html" title="A class that helps you invoke MacroProcessor on on a set of source files, given a set of command-line...">LeMP.Compiler</a>. </p>
<p>For more information about how to use LLLPG, read <a href="http://www.codeproject.com/Articles/664785/A-New-Parser-Generator-for-Csharp">http://www.codeproject.com/Articles/664785/A-New-Parser-Generator-for-Csharp</a> </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Nested classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1ComputeNext.html">ComputeNext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers a list of all one-token transitions starting from a single position. Also gathers any and-predicates that must be traversed before completing a transition. <a href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1ComputeNext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1GenerateCodeVisitor.html">GenerateCodeVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directs code generation using the visitor pattern to visit the predicates in a rule. The process starts with Generate(Rule).  <a href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1GenerateCodeVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1GetCanonical.html">GetCanonical</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the "canonical" interpretation of a position for prediction purposes, so that ConsolidateDuplicatePositions can detect duplicates reliably. Call <a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1GetCanonical.html#a52af8836f8f2c65b0785b2add390e020" title="Computes the &quot;canonical&quot; interpretation of a position.">Do</a>() to use. <a href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1GetCanonical.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1GrammarPos.html">GrammarPos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a location in a grammar: a predicate and a "return stack" which is a so-called persistent singly-linked list. This type is used within <a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1Transition.html" title="Represents a position in a grammar (GrammarPos) plus the set of characters that leads to that positio...">Transition</a>. <a href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1GrammarPos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1KthSet.html">KthSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the possible interpretations of a single input character, in terms of transitions in the grammar. <a href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1KthSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1PredictionAnalysisVisitor.html">PredictionAnalysisVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs prediction analysis using the visitor pattern to visit the predicates in a rule. The process starts with Analyze(Rule).  <a href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1PredictionAnalysisVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1Transition.html">Transition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a position in a grammar (<a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1GrammarPos.html" title="Represents a location in a grammar: a predicate and a &quot;return stack&quot; which is a so-called persistent ...">GrammarPos</a>) plus the set of characters that leads to that position from the previous position. This is a single case in a <a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1KthSet.html" title="Represents the possible interpretations of a single input character, in terms of transitions in the g...">KthSet</a>. <a href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1Transition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public fields</h2></td></tr>
<tr class="memitem:aa054df00b95c9e9bfb3e0083f36ee816"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html#aa054df00b95c9e9bfb3e0083f36ee816">DefaultK</a> = 2</td></tr>
<tr class="memdesc:aa054df00b95c9e9bfb3e0083f36ee816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the default maximum lookahead for rules that do not specify a lookahead value. <a href="#aa054df00b95c9e9bfb3e0083f36ee816">More...</a><br /></td></tr>
<tr class="separator:aa054df00b95c9e9bfb3e0083f36ee816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca062ad6d2e03acaa435fe91a2f9135"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html#afca062ad6d2e03acaa435fe91a2f9135">NoDefaultArm</a> = false</td></tr>
<tr class="memdesc:afca062ad6d2e03acaa435fe91a2f9135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normally, the last arm in a list of alternatives is chosen as the default. For example, in ("Foo" | "Bar"), the second branch is taken unless the input begins with 'F'. However, if this flag is true, there is no default arm on <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Alts.html" title="Describes a series of alternatives (branches), a kleene star (*), or an optional element (...">Alts</a> unless one is specified explicitly, so a special error branch is generated when none of the alternatives apply. This increases code size and decreases speed, but the generated parser may give better error messages. <a href="#afca062ad6d2e03acaa435fe91a2f9135">More...</a><br /></td></tr>
<tr class="separator:afca062ad6d2e03acaa435fe91a2f9135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e7defec27fc4ffe008852d5c0b148a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html#ab5e7defec27fc4ffe008852d5c0b148a">FullLLk</a> = false</td></tr>
<tr class="memdesc:ab5e7defec27fc4ffe008852d5c0b148a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables full LL(k) instead of "partly approximate" lookahead. <a href="#ab5e7defec27fc4ffe008852d5c0b148a">More...</a><br /></td></tr>
<tr class="separator:ab5e7defec27fc4ffe008852d5c0b148a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffdf62c82de0aeb1a953b3dfba67edd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html#a1ffdf62c82de0aeb1a953b3dfba67edd">Verbosity</a> = 0</td></tr>
<tr class="memdesc:a1ffdf62c82de0aeb1a953b3dfba67edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the verbosity level. Verbose output can help you debug grammars that don't produce the expected code. <a href="#a1ffdf62c82de0aeb1a953b3dfba67edd">More...</a><br /></td></tr>
<tr class="separator:a1ffdf62c82de0aeb1a953b3dfba67edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc72ef47f84486172275c361c995927f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html#acc72ef47f84486172275c361c995927f">AddComments</a> = true</td></tr>
<tr class="memdesc:acc72ef47f84486172275c361c995927f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to insert Specifies the default maximum lookahead for rules that do not specify a lookahead value. <a href="#acc72ef47f84486172275c361c995927f">More...</a><br /></td></tr>
<tr class="separator:acc72ef47f84486172275c361c995927f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae6465e3f7f9d5c47902f08b7198097"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html#a3ae6465e3f7f9d5c47902f08b7198097">AddCsLineDirectives</a> = true</td></tr>
<tr class="memdesc:a3ae6465e3f7f9d5c47902f08b7198097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to add #line directives for C# before and after user actions. <a href="#a3ae6465e3f7f9d5c47902f08b7198097">More...</a><br /></td></tr>
<tr class="separator:a3ae6465e3f7f9d5c47902f08b7198097"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a0f0916e4b7835c1792d412376d55e83c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceLoyc_1_1IMessageSink.html">IMessageSink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html#a0f0916e4b7835c1792d412376d55e83c">Sink</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a0f0916e4b7835c1792d412376d55e83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error or warning occurs while parsing a grammar or while generating code for a parser. Also called to print "verbose" messages. <a href="#a0f0916e4b7835c1792d412376d55e83c">More...</a><br /></td></tr>
<tr class="separator:a0f0916e4b7835c1792d412376d55e83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa034be1f7b0f4b3d92e2ce24f5b465fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa034be1f7b0f4b3d92e2ce24f5b465fc"></a>
<a class="el" href="interfaceLoyc_1_1LLParserGenerator_1_1IPGCodeGenHelper.html">IPGCodeGenHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CodeGenHelper</b><code> [get, set]</code></td></tr>
<tr class="separator:aa034be1f7b0f4b3d92e2ce24f5b465fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8f5f3f753e443aa66fdf298eefe20e2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f5f3f753e443aa66fdf298eefe20e2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LLParserGenerator</b> (<a class="el" href="interfaceLoyc_1_1LLParserGenerator_1_1IPGCodeGenHelper.html">IPGCodeGenHelper</a> csg, <a class="el" href="interfaceLoyc_1_1IMessageSink.html">IMessageSink</a> sink=null)</td></tr>
<tr class="separator:a8f5f3f753e443aa66fdf298eefe20e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da0d517851079350c8381a29702d874"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3da0d517851079350c8381a29702d874"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AddRules</b> (params <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Rule.html">Rule</a>[] rules)</td></tr>
<tr class="separator:a3da0d517851079350c8381a29702d874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf5bd774b9a4800022957f720a8959b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecf5bd774b9a4800022957f720a8959b"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AddRules</b> (IEnumerable&lt; <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Rule.html">Rule</a> &gt; rules)</td></tr>
<tr class="separator:aecf5bd774b9a4800022957f720a8959b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151d356176f2e9d5e8c080dca8101c20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a151d356176f2e9d5e8c080dca8101c20"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AddRule</b> (<a class="el" href="classLoyc_1_1LLParserGenerator_1_1Rule.html">Rule</a> rule)</td></tr>
<tr class="separator:a151d356176f2e9d5e8c080dca8101c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2287db28b2b9044187ab4c62207bcd12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html#a2287db28b2b9044187ab4c62207bcd12">Run</a> (<a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a> sourceFile)</td></tr>
<tr class="memdesc:a2287db28b2b9044187ab4c62207bcd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a braced block of code {...} for the grammar described by the rules that were previously added to this object with AddRule or AddRules(Rule[]). <a href="#a2287db28b2b9044187ab4c62207bcd12">More...</a><br /></td></tr>
<tr class="separator:a2287db28b2b9044187ab4c62207bcd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a90e92b4f9dc6988208e3917e7cee702d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90e92b4f9dc6988208e3917e7cee702d"></a>
static Dictionary&lt; <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a>, <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Rule.html">Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AddRulesToDict</b> (IEnumerable&lt; <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Rule.html">Rule</a> &gt; rules, Dictionary&lt; <a class="el" href="classLoyc_1_1Symbol.html">Symbol</a>, <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Rule.html">Rule</a> &gt; dict=null)</td></tr>
<tr class="separator:a90e92b4f9dc6988208e3917e7cee702d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac3ff86f4e778ae4b2c0bf7b35732df6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3ff86f4e778ae4b2c0bf7b35732df6d"></a>
<a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1KthSet.html">KthSet</a>[]&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeFirstSets</b> (<a class="el" href="classLoyc_1_1LLParserGenerator_1_1Alts.html">Alts</a> alts)</td></tr>
<tr class="separator:ac3ff86f4e778ae4b2c0bf7b35732df6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662d0af91aac9c83e5f0c83a8c262281"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a662d0af91aac9c83e5f0c83a8c262281"></a>
<a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1KthSet.html">KthSet</a>[]&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeNextSets</b> (List&lt; <a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1KthSet.html">KthSet</a> &gt; previous, <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Alts.html">Alts</a> currentAlts)</td></tr>
<tr class="separator:a662d0af91aac9c83e5f0c83a8c262281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafef714126a17ff0b732181c051d9170"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafef714126a17ff0b732181c051d9170"></a>
<a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1KthSet.html">KthSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeNextSet</b> (<a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1KthSet.html">KthSet</a> previous, bool addEOF)</td></tr>
<tr class="separator:aafef714126a17ff0b732181c051d9170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963a4834d664532506aa1c972838b1b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a963a4834d664532506aa1c972838b1b1"></a>
<a class="el" href="structLoyc_1_1void.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MakeCanonical</b> (<a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1KthSet.html">KthSet</a> next)</td></tr>
<tr class="separator:a963a4834d664532506aa1c972838b1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected fields</h2></td></tr>
<tr class="memitem:a6befd2c16f66dcb1ea61b25a42a8cabb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6befd2c16f66dcb1ea61b25a42a8cabb"></a>
<a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_sourceFile</b></td></tr>
<tr class="separator:a6befd2c16f66dcb1ea61b25a42a8cabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d5d93ba9b18c661b2914ef0a971f4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3d5d93ba9b18c661b2914ef0a971f4c"></a>
WList&lt; <a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_classBody</b></td></tr>
<tr class="separator:af3d5d93ba9b18c661b2914ef0a971f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8984103c31dae490e9525ce5d50158f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8984103c31dae490e9525ce5d50158f9"></a>
<a class="el" href="interfaceLoyc_1_1LLParserGenerator_1_1IPGCodeGenHelper.html">IPGCodeGenHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_helper</b> = new <a class="el" href="classLoyc_1_1LLParserGenerator_1_1IntStreamCodeGenHelper.html">IntStreamCodeGenHelper</a>()</td></tr>
<tr class="separator:a8984103c31dae490e9525ce5d50158f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06061a529fa009b25ae2083cbd5dba36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06061a529fa009b25ae2083cbd5dba36"></a>
<a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1ComputeNext.html">ComputeNext</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_computeNext</b> = new <a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1ComputeNext.html">ComputeNext</a>()</td></tr>
<tr class="separator:a06061a529fa009b25ae2083cbd5dba36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a6ccf16511273be5e8b403749fa216"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9a6ccf16511273be5e8b403749fa216"></a>
<a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1GetCanonical.html">GetCanonical</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_getCanonical</b> = new <a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator_1_1GetCanonical.html">GetCanonical</a>()</td></tr>
<tr class="separator:ac9a6ccf16511273be5e8b403749fa216"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Protected static fields</h2></td></tr>
<tr class="memitem:a89a2af20d37dd54f0537ed832eb57113"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89a2af20d37dd54f0537ed832eb57113"></a>
static <a class="el" href="namespaceLoyc.html#aeb4d5c77591b654c8d37485b1dd00f5e">Severity</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Warning</b> = Severity.Warning</td></tr>
<tr class="separator:a89a2af20d37dd54f0537ed832eb57113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04590c7c662a6fe8260c89130439fa5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04590c7c662a6fe8260c89130439fa5c"></a>
static <a class="el" href="namespaceLoyc.html#aeb4d5c77591b654c8d37485b1dd00f5e">Severity</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Error</b> = Severity.Error</td></tr>
<tr class="separator:a04590c7c662a6fe8260c89130439fa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20242b9b930fdf75b71578523fcad2fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20242b9b930fdf75b71578523fcad2fc"></a>
static <a class="el" href="namespaceLoyc.html#aeb4d5c77591b654c8d37485b1dd00f5e">Severity</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Verbose</b> = Severity.Verbose</td></tr>
<tr class="separator:a20242b9b930fdf75b71578523fcad2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2287db28b2b9044187ab4c62207bcd12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoyc_1_1Syntax_1_1LNode.html">LNode</a> Loyc.LLParserGenerator.LLParserGenerator.Run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceLoyc_1_1Syntax_1_1ISourceFile.html">ISourceFile</a>&#160;</td>
          <td class="paramname"><em>sourceFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a braced block of code {...} for the grammar described by the rules that were previously added to this object with AddRule or AddRules(Rule[]).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceFile</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated parser class.</dd></dl>
<p>[This may be outdated, TODO: review it] </p>
<p>By far the greatest difficulty in this process is generating prediction code when the grammar branches: (<code>x | y | z</code>). Since this class creates LL(k) parsers without memoization or implicit backtracking, it relies on prediction trees to correctly decide <em>in advance</em> which branch to follow. </p>
<p>The following kinds of grammar elements require prediction: </p>
<ul>
<li>
<code>a | b</code> (which is equivalent to <code>a / b</code>): prediction chooses between a and b </li>
<li>
<code>a?</code>: prediction chooses between a and whatever follows a? </li>
<li>
<code>a*</code>: prediction chooses between a and whatever follows a* </li>
<li>
<code>(a | b)*: </code>prediction chooses between three alternatives (a, b, and exiting the loop). </li>
<li>
<code>(a | b)?: </code>prediction chooses between three alternatives (a, b, and skipping both). </li>
<li>
<code>a+</code>: exactly equivalent to <code>a a*</code> </li>
</ul>
<p>All of these are based on an <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Alts.html" title="Describes a series of alternatives (branches), a kleene star (*), or an optional element (...">Alts</a> object. </p>
<p>Let's look at a simple example of the prediction code generated for a rule called "Foo": </p><div class="fragment"><div class="line"><span class="comment">// rule a @[ &#39;a&#39; | &#39;A&#39; ];</span></div>
<div class="line"><span class="comment">// rule b @[ &#39;b&#39; | &#39;B&#39; ];</span></div>
<div class="line"><span class="comment">// public rule Foo @[ a | b ];</span></div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> Foo()</div>
<div class="line">{</div>
<div class="line">  var la0 = LA0;</div>
<div class="line">  <span class="keywordflow">if</span> (la0 == <span class="charliteral">&#39;a&#39;</span> || la0 == <span class="charliteral">&#39;A&#39;</span>)</div>
<div class="line">    a();</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    b();</div>
<div class="line">}</div>
</div><!-- fragment --><p> By default, to make prediction more efficient, the last alternative is assumed to match if the others don't. So when <code>a</code> doesn't match, <code>b</code> is called even though it has not been verified to match yet. This behavior can be changed by setting <a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html#afca062ad6d2e03acaa435fe91a2f9135" title="Normally, the last arm in a list of alternatives is chosen as the default. For example, in (&quot;Foo&quot; | &quot;Bar&quot;), the second branch is taken unless the input begins with &#39;F&#39;. However, if this flag is true, there is no default arm on Alts unless one is specified explicitly, so a special error branch is generated when none of the alternatives apply. This increases code size and decreases speed, but the generated parser may give better error messages.">NoDefaultArm</a>=true. </p>
<p>Alternatively, you can select the default using the 'default' keyword, which controls the <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Alts.html#aa42f5797f460395295450b35e15b91e9" title="Specifies the case that should be encoded as the default in the prediction tree, i.e., the else clause in the if-else chain or the &quot;default:&quot; label in the switch statement.">Alts.DefaultArm</a> property, e.g. </p><div class="fragment"><div class="line"><span class="comment">// public rule Foo ==&gt; @[ default a | b ];</span></div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> Foo()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> la0;</div>
<div class="line">  la0 = LA(0);</div>
<div class="line">  <span class="keywordflow">if</span> (la0 == <span class="charliteral">&#39;b&#39;</span> || la0 == <span class="charliteral">&#39;B&#39;</span>)</div>
<div class="line">    b();</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    a();</div>
<div class="line">}</div>
</div><!-- fragment --><p> In simple cases like this one that only require LL(1) prediction, prediction and matching are merged into a single if-else chain. In more complicated cases, goto statements may be used to avoid code duplication (ANTLR uses pairs of if-else or switch statements instead, but I chose to use gotos because the generated code will be faster.) The if-else statements are the "prediction" part of the code, while the calls to a() and b() are the "matching" part. </p>
<p>Here's another example: </p><div class="fragment"><div class="line"><span class="comment">// public rule Foo ==&gt; @[ (a | b? &#39;c&#39;)* ];</span></div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> Foo()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> la0;</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    la0 = LA(0);</div>
<div class="line">    <span class="keywordflow">if</span> (la0 == <span class="charliteral">&#39;a&#39;</span> || la0 == <span class="charliteral">&#39;A&#39;</span>)</div>
<div class="line">      a();</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (la0 == <span class="charliteral">&#39;b&#39;</span> || la0 == <span class="charliteral">&#39;B&#39;</span> || la0 == <span class="charliteral">&#39;c&#39;</span>) {</div>
<div class="line">      la0 = LA(0);</div>
<div class="line">      <span class="keywordflow">if</span> (la0 == <span class="charliteral">&#39;b&#39;</span> || la0 == <span class="charliteral">&#39;B&#39;</span>)</div>
<div class="line">        b();</div>
<div class="line">      Match(<span class="charliteral">&#39;c&#39;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span></div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> A kleene star (*) always produces a "for(;;)" loop, while an optional item may produce a "do ... while(false)" pseudo-loop in some circumstances (but this case is too simple to require it). Here there are two separate prediction phases: one for the outer loop <code>(a | b? 'c')*</code>, and one for <code>b?</code>. </p>
<p>In this example, the loop appears at the end of the rule. In some such cases, the "follow set" of the rule becomes relevant. In order for the parser to decide whether to exit the loop or not, it may need to know what can follow the loop. For instance, if <code>('a' 'b')*</code> is followed by 'a'..'z' 'c', it is not possible to tell whether to stay in the loop or exit just by looking at the first input character. If LA(0) is 'a', it is necessary to look at the second character LA(1); only if the second character is 'b' is it possible to conclude that 'a' 'b' should be matched. </p>
<p>Therefore, before generating a parser one of the steps is to build the follow set of each rule, by looking for places where a rule appears inside other rules. A rule is not aware of its current caller, so it gathers information from all call sites and merges it together. When a rule is marked "public", it is considered to be a starting rule, which causes the follow set to include $ (which means "end of input"). </p>
<p>The fact that LLLPG is aware of follow sets and the differences between alternatives, and the fact that its generated parsers do not normally backtrack, makes LLLPG's LL(k) parsing tecnique fundamentally different from another popular parsing technique, PEG. The documentation of <a class="el" href="classLoyc_1_1LLParserGenerator_1_1LLParserGenerator.html" title="Encapsulates LLLPG, the Loyc LL Parser Generator, which generates LL(k) recursive-descent parsers...">LLParserGenerator</a> explains further. </p>
<p>Here's an example that needs more than one character of lookahead: </p><div class="fragment"><div class="line"><span class="comment">// public rule Foo ==&gt; @[ &#39;a&#39;..&#39;z&#39;+ | &#39;x&#39; &#39;0&#39;..&#39;9&#39; &#39;0&#39;..&#39;9&#39; ];</span></div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> Foo()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> la0, la1;</div>
<div class="line">  <span class="keywordflow">do</span> {</div>
<div class="line">    la0 = LA(0);</div>
<div class="line">    <span class="keywordflow">if</span> (la0 == <span class="charliteral">&#39;x&#39;</span>) {</div>
<div class="line">      la1 = LA(1);</div>
<div class="line">      <span class="keywordflow">if</span> (la1 &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;amp;&amp;amp; <span class="charliteral">&#39;9&#39;</span> &gt;= la1) {</div>
<div class="line">        Match();</div>
<div class="line">        Match();</div>
<div class="line">        MatchRange(<span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;9&#39;</span>);</div>
<div class="line">      } <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">goto</span> match1;</div>
<div class="line">    } <span class="keywordflow">else</span></div>
<div class="line">      <span class="keywordflow">goto</span> match1;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">    match1:</div>
<div class="line">    {</div>
<div class="line">      Match();</div>
<div class="line">      <span class="keywordflow">for</span> (;;) {</div>
<div class="line">        la0 = LA(0);</div>
<div class="line">        <span class="keywordflow">if</span> (la0 &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;amp;&amp;amp; <span class="charliteral">&#39;z&#39;</span> &gt;= la0)</div>
<div class="line">          Match();</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here, the prediction and matching phases are merged for the second alternative, but separate for the first alternative (because it is chosen in two different places in the prediction logic). Notice that the matching for alt 2 starts with <code>Match()</code> twice, with no arguments, but is followed by <code>MatchRange('a', 'z')</code>. This demonstrates communication from prediction to matching: the matching phase can tell that LA(0) is confirmed to be 'x', and LA(1) is confirmed to be '0'..'9', so an unconditional match suffices. However, nothing is known about LA(2) so its value must be checked, which is what MatchRange() is supposed to do. </p>
<p>In some cases, LA(0) is irrelevant. Consider this example: </p><div class="fragment"><div class="line"><span class="comment">// public rule Foo ==&gt; @[ &#39;(&#39; &#39;a&#39;..&#39;z&#39;* &#39;)&#39; | &#39;(&#39; &#39;0&#39;..&#39;9&#39;+ &#39;)&#39; ];</span></div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> Foo()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> la0, la1;</div>
<div class="line">  la1 = LA(1);</div>
<div class="line">  <span class="keywordflow">if</span> (la1 &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;amp;&amp;amp; <span class="charliteral">&#39;z&#39;</span> &gt;= la1) {</div>
<div class="line">    Match(<span class="charliteral">&#39;(&#39;</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (;;) {</div>
<div class="line">      la0 = LA(0);</div>
<div class="line">      <span class="keywordflow">if</span> (la0 &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;amp;&amp;amp; <span class="charliteral">&#39;z&#39;</span> &gt;= la0)</div>
<div class="line">        Match();</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    Match(<span class="charliteral">&#39;)&#39;</span>);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    Match(<span class="charliteral">&#39;(&#39;</span>);</div>
<div class="line">    MatchRange(<span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;9&#39;</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (;;) {</div>
<div class="line">      la0 = LA(0);</div>
<div class="line">      <span class="keywordflow">if</span> (la0 &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;amp;&amp;amp; <span class="charliteral">&#39;9&#39;</span> &gt;= la0)</div>
<div class="line">        Match();</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    Match(<span class="charliteral">&#39;)&#39;</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here, the first character of both alternatives is always '(', so looking at LA(0) doesn't help choose which branch to take, and prediction skips ahead to LA(1).</p>
<h3>And-predicates</h3>
<p>An and-predicate specifies an extra condition on the input that must be checked. Here is a simple example: </p><div class="fragment"><div class="line">(&amp;amp;{flag} <span class="charliteral">&#39;0&#39;</span>..<span class="charliteral">&#39;9&#39;</span> | <span class="charliteral">&#39;a&#39;</span>..<span class="charliteral">&#39;z&#39;</span>)</div>
</div><!-- fragment --><p> This example says that '0'..'9' is only allowed if the expression <code>flag</code> evaluates to true, otherwise 'a'..'z' is required. <a class="el" href="namespaceLoyc_1_1LLPG.html">LLPG</a>, however, gives and-predicates lower priority, and always inverts the order of the testing: it checks for '0'..'9' first, then checks <code>flag</code> afterward. I chose to make <a class="el" href="namespaceLoyc_1_1LLPG.html">LLPG</a> work this way because in general, and- predicates can be much more expensive to check than character sets; if one of the alternatives rarely runs, it would be wasteful to check an expensive and-predicate before checking if the input character could possibly match. Therefore, the generated code looks like this: </p><div class="fragment"><div class="line">la0 = LA(0);</div>
<div class="line"><span class="keywordflow">if</span> (la0 &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;amp;&amp;amp; la0 &amp;lt;= <span class="charliteral">&#39;9&#39;</span>) {</div>
<div class="line">   Check(flag);</div>
<div class="line">   Match();</div>
<div class="line">} <span class="keywordflow">else</span></div>
<div class="line">   MatchRange(<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;z&#39;</span>);</div>
</div><!-- fragment --><p> If you really need to make the and-predicate run first for some reason, I dunno. I got nothin'. Complain to me every month until I implement something, maybe. </p>
<p>A generated parser performs prediction in two interleaved parts: character-set tests, and and-predicate tests. In this example, </p><div class="fragment"><div class="line">(<span class="charliteral">&#39;0&#39;</span>..<span class="charliteral">&#39;9&#39;</span>+ | &amp;amp;{hexAllowed} <span class="charliteral">&#39;0&#39;</span> <span class="charliteral">&#39;x&#39;</span> (<span class="charliteral">&#39;0&#39;</span>..<span class="charliteral">&#39;9&#39;</span>|<span class="charliteral">&#39;a&#39;</span>..<span class="charliteral">&#39;f&#39;</span>)+)</div>
</div><!-- fragment --><p> The code will look like this: </p><div class="fragment"><div class="line"><span class="keywordflow">do</span> {</div>
<div class="line">  la0 = LA(0);</div>
<div class="line">  <span class="keywordflow">if</span> (la0 == <span class="charliteral">&#39;0&#39;</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> (hexAllowed) {</div>
<div class="line">      la1 = LA(1);</div>
<div class="line">      <span class="keywordflow">if</span> (la1 == <span class="charliteral">&#39;x&#39;</span>) {</div>
<div class="line">        Match();</div>
<div class="line">        Match();</div>
<div class="line">        MatchRange(<span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;9&#39;</span>, <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;f&#39;</span>);</div>
<div class="line">        ...</div>
<div class="line">      } <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">goto</span> match1;</div>
<div class="line">    } <span class="keywordflow">else</span></div>
<div class="line">      <span class="keywordflow">goto</span> match1;</div>
<div class="line">  } <span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">goto</span> match1;</div>
<div class="line">  <span class="keywordflow">break</span>;</div>
<div class="line">  match1:;</div>
<div class="line">  {</div>
<div class="line">    MatchRange(<span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;9&#39;</span>);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">} <span class="keywordflow">while</span> (<span class="keyword">false</span>);</div>
</div><!-- fragment --><p> Here you can see the interleaving: first the parser checks LA(0), then it checks the and-predicate, then it checks LA(1). </p>
<p><a class="el" href="namespaceLoyc_1_1LLPG.html">LLPG</a> (let's call it 1.0) does not support any analysis of the <em>contents</em> of an and-predicate. Thus, without loss of generality, these examples use semantic predicates &amp;{...} instead of syntactic predicates &amp;(...); <a class="el" href="namespaceLoyc_1_1LLPG.html">LLPG</a> can't "see inside them" either way. </p>
<p>Even without analyzing the contents of an and-predicate, they can still make prediction extremely complicated. Consider this example: </p><div class="fragment"><div class="line">(.&amp;amp;{a} (&amp;amp;{b} {B();} | &amp;amp;{c})</div>
<div class="line">  &amp;amp;{d} [&amp;amp;{e} (<span class="charliteral">&#39;e&#39;</span>|<span class="charliteral">&#39;E&#39;</span>)]?</div>
<div class="line">  (&amp;amp;{f} (<span class="charliteral">&#39;f&#39;</span>|<span class="charliteral">&#39;t&#39;</span>) | <span class="charliteral">&#39;F&#39;</span>)</div>
<div class="line">| &amp;amp;{c} (&amp;amp;{f} (<span class="charliteral">&#39;e&#39;</span>|<span class="charliteral">&#39;t&#39;</span>) | <span class="charliteral">&#39;f&#39;</span>) <span class="charliteral">&#39;g&#39;</span></div>
<div class="line">| <span class="charliteral">&#39;!&#39;</span> )</div>
</div><!-- fragment --><p> In this example, the first branch requires 'a' and 'd' to be true, there's a pair of zero-width alternatives that require 'b' or 'c' to be true, {B()} must be executed if 'b' is true, 'e' must be true if LA(0) is ('e'|'E'), 'f' must be true if LA(0) is 'f' and no condition is required for 'F'. The second branch also allows 'e' or 'f', provided that 'c' is true, but requires 'f' if LA(0) is 'e'. </p>
<p>LLLPG appears to handle this case correctly. </p>

<p>References <a class="el" href="classLoyc_1_1Localize.html#a43de4c76abc8352800a789b371e15a8e">Loyc.Localize.Localized()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="acc72ef47f84486172275c361c995927f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.LLParserGenerator.LLParserGenerator.AddComments = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to insert Specifies the default maximum lookahead for rules that do not specify a lookahead value.</p>

</div>
</div>
<a class="anchor" id="a3ae6465e3f7f9d5c47902f08b7198097"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.LLParserGenerator.LLParserGenerator.AddCsLineDirectives = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to add #line directives for C# before and after user actions.</p>

</div>
</div>
<a class="anchor" id="aa054df00b95c9e9bfb3e0083f36ee816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.LLParserGenerator.LLParserGenerator.DefaultK = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the default maximum lookahead for rules that do not specify a lookahead value.</p>

</div>
</div>
<a class="anchor" id="ab5e7defec27fc4ffe008852d5c0b148a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.LLParserGenerator.LLParserGenerator.FullLLk = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables full LL(k) instead of "partly approximate" lookahead.</p>
<p>LLLPG's standard disambiguation mode is similar to the "linear 
approximate" lookahead present in the ANTLR v2 parser generator. The original linear approximate lookahead fails to predict the following case correctly: </p><div class="fragment"><div class="line">Foo ==&gt; @[ (<span class="charliteral">&#39;a&#39;</span> <span class="charliteral">&#39;b&#39;</span> | <span class="charliteral">&#39;c&#39;</span> <span class="charliteral">&#39;d&#39;</span>) <span class="charliteral">&#39;;&#39;</span> </div>
<div class="line">         | <span class="charliteral">&#39;a&#39;</span> <span class="charliteral">&#39;d&#39;</span>             <span class="charliteral">&#39;;&#39;</span> ];</div>
</div><!-- fragment --><p> LLLPG has no problem with this case. However, LLLPG's "somewhat
approximate" lookahead still has problems with certain cases involving nested alternatives. Here's a case that it can't handle: </p><div class="fragment"><div class="line">Foo ==&gt; @[ (<span class="charliteral">&#39;a&#39;</span> <span class="charliteral">&#39;b&#39;</span> | <span class="charliteral">&#39;b&#39;</span> <span class="charliteral">&#39;a&#39;</span>) <span class="charliteral">&#39;;&#39;</span> </div>
<div class="line">         | (<span class="charliteral">&#39;a&#39;</span> <span class="charliteral">&#39;a&#39;</span> | <span class="charliteral">&#39;b&#39;</span> <span class="charliteral">&#39;b&#39;</span>) <span class="charliteral">&#39;;&#39;</span> ];</div>
</div><!-- fragment --><p> Basically here's what goes wrong: LLLPG detects that both alternatives can start with 'a' or 'b'. The way it normally builds a prediction tree is by creating a test for the common set between two alternatives: </p><div class="fragment"><div class="line">la0 = LA(0);</div>
<div class="line"><span class="keywordflow">if</span> (la0 == <span class="charliteral">&#39;a&#39;</span> || la0 == <span class="charliteral">&#39;b&#39;</span>) { ... alt 1 or alt 2 ... }</div>
</div><!-- fragment --><p> Then, inside that "if" statement it adds a test for LA(1). Sadly, LLLPG discovers that if (la1 == 'a' || la1 == 'b'), both alternatives still apply. Thus, it can't tell the difference between the two and gives up, picking the first alternative unconditionally and printing a warning that "Branch 2 is unreachable". </p>
<p>To fix this, LLLPG must figure out that it should split the LA(0) test into two separate "if" clauses. I've figured out how to do this, but the new code is experimental, it creates subtly different results than standard prediction, which causes the test suite to fail, it sometimes uses too many branches that are not merged properly, I suspect it might be substantially slower at code generation in some cases, and finally I am worried that it will make the generated code much larger sometimes (although I have not actually found or seen such a case). </p>
<p>So, full LL(k) is disabled by default, but you can enable it if you encounter a problem like this. </p>

</div>
</div>
<a class="anchor" id="afca062ad6d2e03acaa435fe91a2f9135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Loyc.LLParserGenerator.LLParserGenerator.NoDefaultArm = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normally, the last arm in a list of alternatives is chosen as the default. For example, in ("Foo" | "Bar"), the second branch is taken unless the input begins with 'F'. However, if this flag is true, there is no default arm on <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Alts.html" title="Describes a series of alternatives (branches), a kleene star (*), or an optional element (...">Alts</a> unless one is specified explicitly, so a special error branch is generated when none of the alternatives apply. This increases code size and decreases speed, but the generated parser may give better error messages.</p>
<p>When this flag is false, an error branch is still generated on a particular loop if requested with <a class="el" href="classLoyc_1_1LLParserGenerator_1_1Alts.html#ae02c825beea98c33c37f103592967b7a" title="Specifies the action to take for error input. If an error branch is specified, it serves as the defau...">Alts.ErrorBranch</a>.</p>

</div>
</div>
<a class="anchor" id="a1ffdf62c82de0aeb1a953b3dfba67edd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Loyc.LLParserGenerator.LLParserGenerator.Verbosity = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets or sets the verbosity level. Verbose output can help you debug grammars that don't produce the expected code.</p>
<p>Level 1 verbosity prints simplified prediction trees in each rule, and the follow sets of each rule. Level 2 verbosity prints prediction trees before they are simplified, and before they have been extended to handle unspecified cases (e.g. if your rule says 'a' 'b' | 'c' 'd', the unspecified cases are all other possible inputs.) Level 3 verbosity prints level 1 and 2 information. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a0f0916e4b7835c1792d412376d55e83c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceLoyc_1_1IMessageSink.html">IMessageSink</a> Loyc.LLParserGenerator.LLParserGenerator.Sink</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an error or warning occurs while parsing a grammar or while generating code for a parser. Also called to print "verbose" messages.</p>
<p>The parameters are (1) a Node that represents the location of the error, or Node.Missing if the grammar was created programmatically without any source code backing it; (2) a predicate related to the error, or null if the error is a syntax error; (3) "Warning" for a warning, "Error" for an error, or "Verbose"; and (4) the text of the error message.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 24 2016 09:22:22 for Enhanced C# by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
